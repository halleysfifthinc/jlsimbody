// common.h
typename SimTK::NiceTypeName;
typename SimTK::Is64BitHelper;
typename SimTK::IsArithmeticType;
typename SimTK::IsVoidType;
typename SimTK::IsFloatingType;
typename SimTK::IsIntegralType;
typename SimTK::XorOpType;
typename SimTK::OrOpType;
typename SimTK::AndOpType;
typename SimTK::TrueType;
typename SimTK::FalseType;
typename SimTK::TrustMe;
typename SimTK::DontCopy;
typename SimTK::CNT;
typename SimTK::Segment;

// Row.h
int SimTK::Row::size();
int SimTK::Row::nrow();
int SimTK::Row::ncol();
typename SimTK::Row::THerm;
const SimTK::Row::THerm & SimTK::Row::transpose();
SimTK::Row::THerm & SimTK::Row::updTranspose();
const SimTK::Row::THerm & SimTK::Row::operator~();
SimTK::Row::THerm & SimTK::Row::operator~();
typename SimTK::Row::TPosTrans;
const SimTK::Row::TPosTrans & SimTK::Row::positionalTranspose();
SimTK::Row::TPosTrans & SimTK::Row::updPositionalTranspose();
typename SimTK::Row::TSqrt;
SimTK::Row::TSqrt SimTK::Row::sqrt();
typename SimTK::Row::TInvert;
SimTK::Row::TInvert SimTK::Row::invert();
typename SimTK::Row::TNormalize;
typename SimTK::Row::TNeg;
SimTK::Row::TNormalize SimTK::Row::normalize();
const SimTK::Row::TNeg & SimTK::Row::operator-();
SimTK::Row::TNeg & SimTK::Row::operator-();
const SimTK::Row::TWithoutNegator & SimTK::Row::castAwayNegatorIfAny();
SimTK::Row::TWithoutNegator & SimTK::Row::updCastAwayNegatorIfAny();
const SimTK::Row::TNeg & SimTK::Row::negate();
SimTK::Row::TNeg & SimTK::Row::updNegate();
SimTK::Row::TStandard SimTK::Row::standardize();
double SimTK::Row::getDefaultTolerance();
const SimTK::Row::TReal & SimTK::Row::real();
SimTK::Row::TReal & SimTK::Row::real();
const SimTK::Row::TImag & SimTK::Row::imag();
SimTK::Row::TImag & SimTK::Row::imag();
typename CNT<ScalarNormSq>::TSqrt SimTK::Row::norm();
const Row<N, ELT, STRIDE> & SimTK::Row::operator+();

Row<N, ELT, STRIDE> & SimTK::Row::scalarEq(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarPlusEq(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarMinusEq(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarTimesEq(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarDivideEq(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarMinusEqFromLeft(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarTimesEqFromLeft(int);
Row<N, ELT, STRIDE> & SimTK::Row::scalarDivideEqFromLeft(int);
Row<N - 1, ELT, 1> SimTK::Row::drop1(int);
Row<N, ELT, 1> SimTK::Row::getNaN();
