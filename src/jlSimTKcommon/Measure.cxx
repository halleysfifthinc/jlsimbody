// this file was auto-generated by wrapit v0.1.0-61-g71d8603-dirty
#include "jlsimbody/common.h"

#include "jlSimTKcommon/Measure.h"

#define ISA_MEASURE_TYPE(T) \
  static_cast<bool (*)(const SimTK::AbstractMeasure &) >(&T::isA)

#define GETAS_MEASURE_TYPE(cast, T) \
  cast<const T & (*)(const SimTK::AbstractMeasure &) >(&T::getAs)

#define UPDAS_MEASURE_TYPE(cast, T) \
  cast<T & (*)(SimTK::AbstractMeasure &) >(&T::updAs)

namespace jlsimbody {

void define_SimTKcommon_Measure(jlcxx::Module& types, jlcxx::TypeWrapper<SimTK::AbstractMeasure>& abs_meas, const ArrayWrapper& array_wrapper){

  DEBUG_MSG("enum SimTK::Measure_::Extreme::Operation (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:841:10
  types.add_bits<typename SimTK::Measure_<double>::Extreme::Operation>("Measure_ExtremeOperation", jlcxx::julia_type("CppEnum"));
  types.set_const("Measure_Extreme_MaxAbs", SimTK::Measure_<double>::Extreme::MaxAbs);
  types.set_const("Measure_Extreme_Maximum", SimTK::Measure_<double>::Extreme::Maximum);
  types.set_const("Measure_Extreme_MinAbs", SimTK::Measure_<double>::Extreme::MinAbs);
  types.set_const("Measure_Extreme_Minimum", SimTK::Measure_<double>::Extreme::Minimum);
  CLEAR_DEBUG_MSG();

  // defined in SimTKcommon/internal/Measure.h:263:7
  auto t3 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("Measure", abs_meas.dt());

  DEBUG_MSG("type SimTK::Measure_::Constant (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:341:20
  auto t4 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ConstantMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Zero (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:371:20
  auto t5 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ZeroMeasure", t4.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::One (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:391:20
  auto t7 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("OneMeasure", t4.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Time (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:409:20
  auto t9 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TimeMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Variable (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:422:20
  auto t10 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("VariableMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Result (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:457:20
  auto t11 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ResultMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Sinusoid (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:575:20
  auto t12 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SinusoidMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Plus (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:597:20
  auto t13 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("PlusMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Minus (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:622:20
  auto t14 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("MinusMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Scale (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:647:20
  auto t15 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ScaleMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Integrate (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:677:20
  auto t16 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("IntegrateMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Differentiate (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:744:20
  auto t17 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("DifferentiateMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Extreme (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:837:20
  auto t18 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ExtremeMeasure", t3.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Minimum (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:885:20
  auto t20 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("MinimumMeasure", t18.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::Maximum (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:895:20
  auto t21 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("MaximumMeasure", t18.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::MaxAbs (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:905:20
  auto t22 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("MaxAbsMeasure", t18.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Measure_::MinAbs (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:916:20
  auto t23 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("MinAbsMeasure", t18.dt());
  CLEAR_DEBUG_MSG();

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::AbstractMeasure
   */


  // DEBUG_MSG("void SimTK::AbstractMeasure::AbstractMeasure(SimTK::AbstractMeasure::Implementation *) (" __HERE__ ")");
  // // defined in SimTKcommon/internal/Measure.h:164:14
  // abs_meas.constructor<SimTK::AbstractMeasure::Implementation *>();
  // CLEAR_DEBUG_MSG();

  DEBUG_MSG("void SimTK::AbstractMeasure::AbstractMeasure(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:174:5
  abs_meas.constructor<const SimTK::AbstractMeasure &>();
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::AbstractMeasure & SimTK::AbstractMeasure::operator=(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:179:22
  abs_meas.method("set!", static_cast<SimTK::AbstractMeasure & (SimTK::AbstractMeasure::*)(const SimTK::AbstractMeasure &) >(&SimTK::AbstractMeasure::operator=));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::AbstractMeasure & SimTK::AbstractMeasure::shallowAssign(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:191:22
  abs_meas.method("shallowAssign", static_cast<SimTK::AbstractMeasure & (SimTK::AbstractMeasure::*)(const SimTK::AbstractMeasure &) >(&SimTK::AbstractMeasure::shallowAssign));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::AbstractMeasure & SimTK::AbstractMeasure::deepAssign(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:197:22
  abs_meas.method("deepAssign", static_cast<SimTK::AbstractMeasure & (SimTK::AbstractMeasure::*)(const SimTK::AbstractMeasure &) >(&SimTK::AbstractMeasure::deepAssign));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("int SimTK::AbstractMeasure::getNumTimeDerivatives() (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:206:9
  abs_meas.method("getNumTimeDerivatives", static_cast<int (SimTK::AbstractMeasure::*)()  const>(&SimTK::AbstractMeasure::getNumTimeDerivatives));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Stage SimTK::AbstractMeasure::getDependsOnStage(int) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:216:11
  abs_meas.method("getDependsOnStage", static_cast<SimTK::Stage (SimTK::AbstractMeasure::*)(int)  const>(&SimTK::AbstractMeasure::getDependsOnStage));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("bool SimTK::AbstractMeasure::isSameMeasure(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:220:10
  abs_meas.method("isSameMeasure", static_cast<bool (SimTK::AbstractMeasure::*)(const SimTK::AbstractMeasure &)  const>(&SimTK::AbstractMeasure::isSameMeasure));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("bool SimTK::AbstractMeasure::isInSubsystem() (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:226:10
  abs_meas.method("isInSubsystem", static_cast<bool (SimTK::AbstractMeasure::*)()  const>(&SimTK::AbstractMeasure::isInSubsystem));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Subsystem & SimTK::AbstractMeasure::getSubsystem() (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:230:22
  abs_meas.method("getSubsystem", static_cast<const SimTK::Subsystem & (SimTK::AbstractMeasure::*)()  const>(&SimTK::AbstractMeasure::getSubsystem));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("bool SimTK::AbstractMeasure::isSameSubsystem(const SimTK::Subsystem &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:232:10
  abs_meas.method("isSameSubsystem", static_cast<bool (SimTK::AbstractMeasure::*)(const SimTK::Subsystem &)  const>(&SimTK::AbstractMeasure::isSameSubsystem));
  CLEAR_DEBUG_MSG();

  #ifdef JLSIMBODY_USE_SIMTK_UNIQUEINDEX_TYPES
  DEBUG_MSG("SimTK::MeasureIndex SimTK::AbstractMeasure::getSubsystemMeasureIndex() (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:236:18
  abs_meas.method("getSubsystemMeasureIndex", static_cast<SimTK::MeasureIndex (SimTK::AbstractMeasure::*)()  const>(&SimTK::AbstractMeasure::getSubsystemMeasureIndex));
  CLEAR_DEBUG_MSG();
  #else
  DEBUG_MSG("int SimTK::AbstractMeasure::getSubsystemMeasureIndex() (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:236:18
  abs_meas.method("getSubsystemMeasureIndex", reinterpret_cast<int (SimTK::AbstractMeasure::*)()  const>(&SimTK::AbstractMeasure::getSubsystemMeasureIndex));
  CLEAR_DEBUG_MSG();
  #endif


  /* End of SimTK::AbstractMeasure class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_
   */
  auto t3_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_<T>> wrapped){
    typedef SimTK::Measure_<T> WrappedType;

    wrapped.template constructor<>();

    DEBUG_MSG("const T & SimTK::Measure_::getValue(const SimTK::State &, int) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:276:14
    wrapped.method("getValue", static_cast<const T & (WrappedType::*)(const SimTK::State &, int)  const>(&WrappedType::getValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("Measure_<T> & SimTK::Measure_::setDefaultValue(const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:285:15
    wrapped.method("setDefaultValue", static_cast<WrappedType & (WrappedType::*)(const T &) >(&WrappedType::setDefaultValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("const T & SimTK::Measure_::getDefaultValue() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:290:14
    wrapped.method("getDefaultValue", static_cast<const T & (WrappedType::*)()  const>(&WrappedType::getDefaultValue));
    CLEAR_DEBUG_MSG();

  };
  t3.apply<
    SimTK::Measure_<double>,
    SimTK::Measure_<SimTK::Vector_<double>>
    >(t3_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:324:5
  types.method("isA_Measure_double", ISA_MEASURE_TYPE(SimTK::Measure_<double>));
  types.method("isA_Measure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T> & SimTK::Measure_::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  // defined in SimTKcommon/internal/Measure.h:324:5
  types.method("getAs_Measure_double", GETAS_MEASURE_TYPE(static_cast,SimTK::Measure_<double>));
  types.method("getAs_Measure_Vector_double", GETAS_MEASURE_TYPE(static_cast,SimTK::Measure_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T> & SimTK::Measure_::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  // // defined in SimTKcommon/internal/Measure.h:324:5
  types.method("updAs_Measure_double", UPDAS_MEASURE_TYPE(static_cast,SimTK::Measure_<double>));
  types.method("updAs_Measure_Vector_double", UPDAS_MEASURE_TYPE(static_cast,SimTK::Measure_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Constant
   */

  auto t4_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Constant_<T>> wrapped){
    typedef SimTK::Measure_Constant_<T> WrappedType;
    // wrapped.template constructor<>();
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Constant());
    });

    DEBUG_MSG("void SimTK::Measure_::Constant::Constant(SimTK::Subsystem &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:343:35
    // wrapped.template constructor<SimTK::Subsystem &>();
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Constant(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Constant::Constant(const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:347:14
    // wrapped.template constructor<const T &>();
    wrapped.constructor([] (const T& val) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Constant(val));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Constant::Constant(SimTK::Subsystem &, const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:352:5
    // wrapped.template constructor<SimTK::Subsystem &, const T &>();
    wrapped.constructor([] (SimTK::Subsystem& sub, const T& val) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Constant(sub, val));
    });
    CLEAR_DEBUG_MSG();
  };
  t4.apply<
    SimTK::Measure_Constant_<double>,
    SimTK::Measure_Constant_<SimTK::Vector_<double>>
    >(t4_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Constant::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_ConstantMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Constant_<double>));
  types.method("isA_ConstantMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Constant_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Constant & SimTK::Measure_<T>::Constant::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_ConstantMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Constant_<double>));
  types.method("getAs_ConstantMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Constant_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Constant & SimTK::Measure_<T>::Constant::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_ConstantMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Constant_<double>));
  types.method("updAs_ConstantMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Constant_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Zero
   */

  auto t5_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Zero_<T>> wrapped){
    typedef SimTK::Measure_Zero_<T> WrappedType;

    if constexpr (std::is_same<T,SimTK::Vector_<double>>::value) {
      wrapped.constructor([] (int size) {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Zero(size));
      });
      wrapped.constructor([] (SimTK::Subsystem& sub, int size) {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Zero(sub, size));
      });
    } else {
      wrapped.constructor([] () {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Zero());
      });
      wrapped.constructor([] (SimTK::Subsystem& sub) {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Zero(sub));
      });
    }
  };
  t5.apply<
    SimTK::Measure_Zero_<double>,
    SimTK::Measure_Zero_<SimTK::Vector_<double>>
    >(t5_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Zero::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_ZeroMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Zero_<double>));
  types.method("isA_ZeroMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Zero_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Zero & SimTK::Measure_<T>::Zero::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_ZeroMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Zero_<double>));
  types.method("getAs_ZeroMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Zero_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Zero & SimTK::Measure_<T>::Zero::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_ZeroMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Zero_<double>));
  types.method("updAs_ZeroMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Zero_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Zero class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::One
   */

  auto t7_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_One_<T>> wrapped){
    typedef SimTK::Measure_One_<T> WrappedType;

    if constexpr (std::is_same<T,SimTK::Vector_<double>>::value) {
      wrapped.constructor([] (int size) {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::One(size));
      });
      wrapped.constructor([] (SimTK::Subsystem& sub, int size) {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::One(sub, size));
      });
    } else {
      wrapped.constructor([] () {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::One());
      });
      wrapped.constructor([] (SimTK::Subsystem& sub) {
        return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::One(sub));
      });
    }
  };
  t7.apply<
    SimTK::Measure_One_<double>,
    SimTK::Measure_One_<SimTK::Vector_<double>>
    >(t7_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::One::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_OneMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_One_<double>));
  types.method("isA_OneMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_One_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::One & SimTK::Measure_<T>::One::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_OneMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_One_<double>));
  types.method("getAs_OneMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_One_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::One & SimTK::Measure_<T>::One::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_OneMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_One_<double>));
  types.method("updAs_OneMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_One_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::One class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Time
   */

  auto t9_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Time_<T>> wrapped){
    typedef SimTK::Measure_Time_<T> WrappedType;
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Time());
    });
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Time(sub));
    });
  };
  t9.apply<
    SimTK::Measure_Time_<double>
    >(t9_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Time::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_TimeMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Time_<double>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Time & SimTK::Measure_<T>::Time::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_TimeMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Time_<double>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Time & SimTK::Measure_<T>::Time::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_TimeMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Time_<double>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Time class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Variable
   */

  auto t10_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Variable_<T>> wrapped){
    typedef SimTK::Measure_Variable_<T> WrappedType;
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Variable());
    });
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Variable(sub));
    });
    wrapped.constructor([] (SimTK::Subsystem& sub, SimTK::Stage invalidates, const T& val) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Variable(sub, invalidates, val));
    });

    wrapped.method("setValue", static_cast<void (WrappedType::*)(SimTK::State &, const T &) const>(&WrappedType::setValue));
  };
  t10.apply<
    SimTK::Measure_Variable_<double>
    >(t10_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Variable::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_VariableMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Variable_<double>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Variable & SimTK::Measure_<T>::Variable::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_VariableMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Variable_<double>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Variable & SimTK::Measure_<T>::Variable::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_VariableMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Variable_<double>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Variable class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Result
   */

  auto t11_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Result_<T>> wrapped){
    typedef SimTK::Measure_Result_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Result::Result(SimTK::Measure_::Result::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Result());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Result::Result(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Result(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Result::Result(SimTK::Subsystem &, SimTK::Stage, SimTK::Stage) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub, SimTK::Stage dependsOn, SimTK::Stage invalidates) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Result(sub, dependsOn, invalidates));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Stage SimTK::Measure_::Result::getDependsOnStage() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:484:11
    wrapped.method("getDependsOnStage", static_cast<SimTK::Stage (WrappedType::*)()  const>(&WrappedType::getDependsOnStage));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Stage SimTK::Measure_::Result::getInvalidatedStage() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:486:11
    wrapped.method("getInvalidatedStage", static_cast<SimTK::Stage (WrappedType::*)()  const>(&WrappedType::getInvalidatedStage));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Result & SimTK::Measure_::Result::setDependsOnStage(SimTK::Stage) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:494:13
    wrapped.method("setDependsOnStage", reinterpret_cast<WrappedType & (WrappedType::*)(SimTK::Stage) >(&WrappedType::setDependsOnStage));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Result & SimTK::Measure_::Result::setInvalidatedStage(SimTK::Stage) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:501:13
    wrapped.method("setInvalidatedStage", reinterpret_cast<WrappedType & (WrappedType::*)(SimTK::Stage) >(&WrappedType::setInvalidatedStage));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Result & SimTK::Measure_::Result::setIsPresumedValidAtDependsOnStage(bool) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:516:13
    wrapped.method("setIsPresumedValidAtDependsOnStage", reinterpret_cast<WrappedType & (WrappedType::*)(bool) >(&WrappedType::setIsPresumedValidAtDependsOnStage));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("bool SimTK::Measure_::Result::getIsPresumedValidAtDependsOnStage() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:521:10
    wrapped.method("getIsPresumedValidAtDependsOnStage", static_cast<bool (WrappedType::*)()  const>(&WrappedType::getIsPresumedValidAtDependsOnStage));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T & SimTK::Measure_::Result::updValue(const SimTK::State &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:530:8
    wrapped.method("updValue", static_cast<T & (WrappedType::*)(const SimTK::State &)  const>(&WrappedType::updValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Result::markAsValid(const SimTK::State &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:539:10
    wrapped.method("markAsValid", static_cast<void (WrappedType::*)(const SimTK::State &)  const>(&WrappedType::markAsValid));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("bool SimTK::Measure_::Result::isValid(const SimTK::State &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:544:10
    wrapped.method("isValid", static_cast<bool (WrappedType::*)(const SimTK::State &)  const>(&WrappedType::isValid));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Result::markAsNotValid(const SimTK::State &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:553:10
    wrapped.method("markAsNotValid", static_cast<void (WrappedType::*)(const SimTK::State &)  const>(&WrappedType::markAsNotValid));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Result::setValue(const SimTK::State &, const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:559:10
    wrapped.method("setValue", static_cast<void (WrappedType::*)(const SimTK::State &, const T &)  const>(&WrappedType::setValue));
    CLEAR_DEBUG_MSG();
  };
  t11.apply<
    SimTK::Measure_Result_<double>,
    SimTK::Measure_Result_<SimTK::Vector_<double>>
    >(t11_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Result::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_ResultMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Result_<double>));
  types.method("isA_ResultMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Result_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Result & SimTK::Measure_<T>::Result::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_ResultMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Result_<double>));
  types.method("getAs_ResultMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Result_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Result & SimTK::Measure_<T>::Result::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_ResultMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Result_<double>));
  types.method("updAs_ResultMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Result_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Result class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Sinusoid
   */

  auto t12_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Sinusoid_<T>> wrapped){
    typedef SimTK::Measure_Sinusoid_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Sinusoid::Sinusoid(SimTK::Measure_::Sinusoid::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Sinusoid());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Sinusoid::Sinusoid(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Sinusoid(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Sinusoid::Sinusoid(SimTK::Subsystem &, const T &, const T &, const T &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub, const T & ampl, const T & freq, const T & phase) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Sinusoid(sub, ampl, freq, phase));
    });
    CLEAR_DEBUG_MSG();
  };
  t12.apply<
    SimTK::Measure_Sinusoid_<double>
    >(t12_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Sinusoid::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_SinusoidMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Sinusoid_<double>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Sinusoid & SimTK::Measure_<T>::Sinusoid::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_SinusoidMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Sinusoid_<double>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Sinusoid & SimTK::Measure_<T>::Sinusoid::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_SinusoidMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Sinusoid_<double>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Sinusoid class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Plus
   */

  auto t13_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Plus_<T>> wrapped){
    typedef SimTK::Measure_Plus_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Plus::Plus(SimTK::Measure_::Plus::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Plus());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Plus::Plus(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Plus(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Plus::Plus(SimTK::Subsystem &, const Measure_<T> &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:601:5
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & m1, const SimTK::Measure_<T> & m2) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Plus(sub, m1, m2));
    });
    CLEAR_DEBUG_MSG();
  };
  t13.apply<
    SimTK::Measure_Plus_<double>,
    SimTK::Measure_Plus_<SimTK::Vector_<double>>
    >(t13_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Plus::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_PlusMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Plus_<double>));
  types.method("isA_PlusMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Plus_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const SimTK::Measure_<T>::Plus & SimTK::Measure_<T>::Plus::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_PlusMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Plus_<double>));
  types.method("getAs_PlusMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Plus_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("SimTK::Measure_<T>::Plus & SimTK::Measure_<T>::Plus::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_PlusMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Plus_<double>));
  types.method("updAs_PlusMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Plus_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Plus class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Minus
   */

  auto t14_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Minus_<T>> wrapped){
    typedef SimTK::Measure_Minus_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Minus::Minus(SimTK::Measure_::Minus::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Minus());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Minus::Minus(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Minus(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Minus::Minus(SimTK::Subsystem &, const Measure_<T> &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:601:5
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & m1, const SimTK::Measure_<T> & m2) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Minus(sub, m1, m2));
    });
    CLEAR_DEBUG_MSG();
  };
  t14.apply<
    SimTK::Measure_Minus_<double>,
    SimTK::Measure_Minus_<SimTK::Vector_<double>>
    >(t14_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Minus::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_MinusMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Minus_<double>));
  types.method("isA_MinusMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Minus_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Minus & SimTK::Measure_<T>::Minus::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_MinusMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minus_<double>));
  types.method("getAs_MinusMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minus_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Minus & SimTK::Measure_<T>::Minus::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_MinusMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minus_<double>));
  types.method("updAs_MinusMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minus_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Minus class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Scale
   */

  auto t15_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Scale_<T>> wrapped){
    typedef SimTK::Measure_Scale_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Scale::Scale(SimTK::Measure_::Scale::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Scale());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Scale::Scale(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Scale(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Scale::Scale(SimTK::Subsystem &, SimTK::Real, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:651:5
    wrapped.constructor([] (SimTK::Subsystem& sub, SimTK::Real scale, const SimTK::Measure_<T> & m) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Scale(sub, scale, m));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("const Measure_<T> & SimTK::Measure_::Scale::getOperandMeasure() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:661:24
    wrapped.method("getOperandMeasure", static_cast<const SimTK::Measure_<T> & (WrappedType::*)()  const>(&WrappedType::getOperandMeasure));
    CLEAR_DEBUG_MSG();

  };
  t15.apply<
    SimTK::Measure_Scale_<double>,
    SimTK::Measure_Scale_<SimTK::Vector_<double>>
    >(t15_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Scale::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_ScaleMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Scale_<double>));
  types.method("isA_ScaleMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Scale_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Scale & SimTK::Measure_<T>::Scale::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_ScaleMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Scale_<double>));
  types.method("getAs_ScaleMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Scale_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Scale & SimTK::Measure_<T>::Scale::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_ScaleMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Scale_<double>));
  types.method("updAs_ScaleMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Scale_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Scale class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Integrate
   */

  auto t16_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Integrate_<T>> wrapped){
    typedef SimTK::Measure_Integrate_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Integrate::Integrate(SimTK::Measure_::Integrate::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Integrate());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Integrate::Integrate(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Integrate(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Integrate::Integrate(SimTK::Subsystem &, const Measure_<T> &, const Measure_<T> &, const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:687:5
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & deriv, const SimTK::Measure_<T> & ic, const T & init) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Integrate(sub, deriv, ic, init));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Integrate::setValue(SimTK::State &, const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:696:10
    wrapped.method("setValue", static_cast<void (WrappedType::*)(SimTK::State &, const T &)  const>(&WrappedType::setValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("const Measure_<T> & SimTK::Measure_::Integrate::getDerivativeMeasure() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:700:24
    wrapped.method("getDerivativeMeasure", static_cast<const SimTK::Measure_<T> & (WrappedType::*)()  const>(&WrappedType::getDerivativeMeasure));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("const Measure_<T> & SimTK::Measure_::Integrate::getInitialConditionMeasure() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:705:24
    wrapped.method("getInitialConditionMeasure", static_cast<const SimTK::Measure_<T> & (WrappedType::*)()  const>(&WrappedType::getInitialConditionMeasure));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Integrate & SimTK::Measure_::Integrate::setDerivativeMeasure(const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:708:16
    wrapped.method("setDerivativeMeasure", reinterpret_cast<WrappedType & (WrappedType::*)(const SimTK::Measure_<T> &) >(&WrappedType::setDerivativeMeasure));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Integrate & SimTK::Measure_::Integrate::setInitialConditionMeasure(const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:711:16
    wrapped.method("setInitialConditionMeasure", reinterpret_cast<WrappedType & (WrappedType::*)(const SimTK::Measure_<T> &) >(&WrappedType::setInitialConditionMeasure));
    CLEAR_DEBUG_MSG();
  };
  t16.apply<
    SimTK::Measure_Integrate_<double>,
    SimTK::Measure_Integrate_<SimTK::Vector_<double>>
    >(t16_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Integrate::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_IntegrateMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Integrate_<double>));
  types.method("isA_IntegrateMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Integrate_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Integrate & SimTK::Measure_<T>::Integrate::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_IntegrateMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Integrate_<double>));
  types.method("getAs_IntegrateMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Integrate_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Integrate & SimTK::Measure_<T>::Integrate::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_IntegrateMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Integrate_<double>));
  types.method("updAs_IntegrateMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Integrate_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Integrate class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Differentiate
   */

  auto t17_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Differentiate_<T>> wrapped){
    typedef SimTK::Measure_Differentiate_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Differentiate::Differentiate(SimTK::Measure_::Differentiate::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Differentiate());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Differentiate::Differentiate(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Differentiate(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Differentiate::Differentiate(SimTK::Subsystem &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:746:35
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & operand) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Differentiate(sub, operand));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("bool SimTK::Measure_::Differentiate::isUsingApproximation() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:760:10
    wrapped.method("isUsingApproximation", static_cast<bool (WrappedType::*)()  const>(&WrappedType::isUsingApproximation));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("const Measure_<T> & SimTK::Measure_::Differentiate::getOperandMeasure() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:765:24
    wrapped.method("getOperandMeasure", static_cast<const SimTK::Measure_<T> & (WrappedType::*)()  const>(&WrappedType::getOperandMeasure));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Differentiate & SimTK::Measure_::Differentiate::setOperandMeasure(const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:771:20
    wrapped.method("setOperandMeasure", reinterpret_cast<WrappedType & (WrappedType::*)(const SimTK::Measure_<T> &) >(&WrappedType::setOperandMeasure));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Differentiate::setForceUseApproximation(bool) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:777:10
    wrapped.method("setForceUseApproximation", static_cast<void (WrappedType::*)(bool) >(&WrappedType::setForceUseApproximation));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("bool SimTK::Measure_::Differentiate::getForceUseApproximation() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:784:10
    wrapped.method("getForceUseApproximation", static_cast<bool (WrappedType::*)()  const>(&WrappedType::getForceUseApproximation));
    CLEAR_DEBUG_MSG();
  };
  t17.apply<
    SimTK::Measure_Differentiate_<double>,
    SimTK::Measure_Differentiate_<SimTK::Vector_<double>>
    >(t17_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Differentiate::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_DifferentiateMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Differentiate_<double>));
  types.method("isA_DifferentiateMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Differentiate_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Differentiate & SimTK::Measure_<T>::Differentiate::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_DifferentiateMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Differentiate_<double>));
  types.method("getAs_DifferentiateMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Differentiate_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Differentiate & SimTK::Measure_<T>::Differentiate::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_DifferentiateMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Differentiate_<double>));
  types.method("updAs_DifferentiateMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Differentiate_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Differentiate class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Extreme
   */

  auto t18_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Extreme_<T>> wrapped){
    typedef SimTK::Measure_Extreme_<T> WrappedType;
    typedef SimTK::Measure_<double>::Extreme::Operation Operation;

    DEBUG_MSG("void SimTK::Measure_::Extreme::Extreme(SimTK::Measure_::Extreme::Implementation *) (" __HERE__ ")");
    wrapped.constructor([] () {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Extreme());
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Extreme::Extreme(SimTK::Subsystem &) (" __HERE__ ")");
    wrapped.constructor([] (SimTK::Subsystem& sub) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Extreme(sub));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Extreme::Extreme(SimTK::Subsystem &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:839:35
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & operand, Operation  op) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Extreme(sub, operand, static_cast<typename SimTK::Measure_<T>::Extreme::Operation>(op)));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Extreme & SimTK::Measure_::Extreme::setOperation(SimTK::Measure_::Extreme::Operation) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:856:14
    wrapped.method("setOperation", reinterpret_cast<WrappedType & (WrappedType::*)(Operation) >(&WrappedType::setOperation));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Extreme::Operation SimTK::Measure_::Extreme::getOperation() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:860:15
    wrapped.method("getOperation", reinterpret_cast<Operation (WrappedType::*)()  const>(&WrappedType::getOperation));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Real SimTK::Measure_::Extreme::getTimeOfExtremeValue(const SimTK::State &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:867:10
    wrapped.method("getTimeOfExtremeValue", static_cast<SimTK::Real (WrappedType::*)(const SimTK::State &)  const>(&WrappedType::getTimeOfExtremeValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Measure_::Extreme::setValue(SimTK::State &, const T &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:870:10
    wrapped.method("setValue", static_cast<void (WrappedType::*)(SimTK::State &, const T &)  const>(&WrappedType::setValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("const Measure_<T> & SimTK::Measure_::Extreme::getOperandMeasure() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:873:24
    wrapped.method("getOperandMeasure", static_cast<const SimTK::Measure_<T> & (WrappedType::*)()  const>(&WrappedType::getOperandMeasure));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Measure_::Extreme & SimTK::Measure_::Extreme::setOperandMeasure(const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:876:14
    wrapped.method("setOperandMeasure", reinterpret_cast<WrappedType & (WrappedType::*)(const SimTK::Measure_<T> &) >(&WrappedType::setOperandMeasure));
    CLEAR_DEBUG_MSG();
  };
  t18.apply<
    SimTK::Measure_Extreme_<double>,
    SimTK::Measure_Extreme_<SimTK::Vector_<double>>
    >(t18_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Extreme::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_ExtremeMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Extreme_<double>));
  types.method("isA_ExtremeMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Extreme_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Extreme & SimTK::Measure_<T>::Extreme::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_ExtremeMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Extreme_<double>));
  types.method("getAs_ExtremeMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Extreme_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Extreme & SimTK::Measure_<T>::Extreme::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_ExtremeMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Extreme_<double>));
  types.method("updAs_ExtremeMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Extreme_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Extreme class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Minimum
   */

  auto t20_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Minimum_<T>> wrapped){
    typedef SimTK::Measure_Minimum_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Minimum::Minimum(SimTK::Subsystem &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:839:35
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & operand) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Minimum(sub, operand));
    });
    CLEAR_DEBUG_MSG();

  };
  t20.apply<
    SimTK::Measure_Minimum_<double>,
    SimTK::Measure_Minimum_<SimTK::Vector_<double>>
    >(t20_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Minimum::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_MinimumMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Minimum_<double>));
  types.method("isA_MinimumMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Minimum_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Minimum & SimTK::Measure_<T>::Minimum::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_MinimumMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minimum_<double>));
  types.method("getAs_MinimumMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minimum_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Minimum & SimTK::Measure_<T>::Minimum::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_MinimumMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minimum_<double>));
  types.method("updAs_MinimumMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Minimum_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Minimum class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::Maximum
   */

  auto t21_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_Maximum_<T>> wrapped){
    typedef SimTK::Measure_Maximum_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::Maximum::Maximum(SimTK::Subsystem &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:839:35
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & operand) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::Maximum(sub, operand));
    });
    CLEAR_DEBUG_MSG();

  };
  t21.apply<
    SimTK::Measure_Maximum_<double>,
    SimTK::Measure_Maximum_<SimTK::Vector_<double>>
    >(t21_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::Maximum::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_MaximumMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_Maximum_<double>));
  types.method("isA_MaximumMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_Maximum_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::Maximum & SimTK::Measure_<T>::Maximum::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_MaximumMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Maximum_<double>));
  types.method("getAs_MaximumMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Maximum_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::Maximum & SimTK::Measure_<T>::Maximum::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_MaximumMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Maximum_<double>));
  types.method("updAs_MaximumMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_Maximum_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::Maximum class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::MaxAbs
   */

  auto t22_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_MaxAbs_<T>> wrapped){
    typedef SimTK::Measure_MaxAbs_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::MaxAbs::MaxAbs(SimTK::Subsystem &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:839:35
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & operand) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::MaxAbs(sub, operand));
    });
    CLEAR_DEBUG_MSG();

  };
  t22.apply<
    SimTK::Measure_MaxAbs_<double>,
    SimTK::Measure_MaxAbs_<SimTK::Vector_<double>>
    >(t22_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::MaxAbs::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_MaxAbsMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_MaxAbs_<double>));
  types.method("isA_MaxAbsMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_MaxAbs_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::MaxAbs & SimTK::Measure_<T>::MaxAbs::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_MaxAbsMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MaxAbs_<double>));
  types.method("getAs_MaxAbsMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MaxAbs_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::MaxAbs & SimTK::Measure_<T>::MaxAbs::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_MaxAbsMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MaxAbs_<double>));
  types.method("updAs_MaxAbsMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MaxAbs_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::MaxAbs class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Measure_::MinAbs
   */

  auto t23_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Measure_MinAbs_<T>> wrapped){
    typedef SimTK::Measure_MinAbs_<T> WrappedType;

    DEBUG_MSG("void SimTK::Measure_::MinAbs::MinAbs(SimTK::Subsystem &, const Measure_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Measure.h:839:35
    wrapped.constructor([] (SimTK::Subsystem& sub, const SimTK::Measure_<T> & operand) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Measure_<T>::MinAbs(sub, operand));
    });
    CLEAR_DEBUG_MSG();

  };
  t23.apply<
    SimTK::Measure_MinAbs_<double>,
    SimTK::Measure_MinAbs_<SimTK::Vector_<double>>
    >(t23_decl_methods);

  DEBUG_MSG("bool SimTK::Measure_<T>::MinAbs::isA(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("isA_MinAbsMeasure_double", ISA_MEASURE_TYPE(SimTK::Measure_MinAbs_<double>));
  types.method("isA_MinAbsMeasure_Vector_double", ISA_MEASURE_TYPE(SimTK::Measure_MinAbs_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("const Measure_<T>::MinAbs & SimTK::Measure_<T>::MinAbs::getAs(const SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("getAs_MinAbsMeasure_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MinAbs_<double>));
  types.method("getAs_MinAbsMeasure_Vector_double", GETAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MinAbs_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("Measure_<T>::MinAbs & SimTK::Measure_<T>::MinAbs::updAs(SimTK::AbstractMeasure &) (" __HERE__ ")");
  types.method("updAs_MinAbsMeasure_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MinAbs_<double>));
  types.method("updAs_MinAbsMeasure_Vector_double", UPDAS_MEASURE_TYPE(reinterpret_cast,SimTK::Measure_MinAbs_<SimTK::Vector_<double>>));
  CLEAR_DEBUG_MSG();

  /* End of SimTK::Measure_::MinAbs class method wrappers
   **********************************************************************/

  array_wrapper.template apply<SimTK::Measure_<double>>();

}

}
