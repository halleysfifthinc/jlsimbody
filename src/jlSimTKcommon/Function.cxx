// this file was auto-generated by wrapit v0.1.0-61-g71d8603-dirty
#include "jlsimbody/common.h"

#include "jlSimTKcommon/Function.h"

namespace jlsimbody {

void define_SimTKcommon_Function(jlcxx::Module& types, const ArrayWrapper & array_wrapper){

  // defined in SimTKcommon/internal/Function.h:51:7
  auto t0 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("Function");

  DEBUG_MSG("type SimTK::Function_::Constant (" __HERE__ ")");
  // defined in SimTKcommon/internal/Function.h:126:21
  auto t1 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ConstantFunction", t0.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Function_::Linear (" __HERE__ ")");
  // defined in SimTKcommon/internal/Function.h:170:21
  auto t2 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("LinearFunction", t0.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Function_::Polynomial (" __HERE__ ")");
  // defined in SimTKcommon/internal/Function.h:223:21
  auto t3 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("PolynomialFunction", t0.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Function_::Sinusoid (" __HERE__ ")");
  // defined in SimTKcommon/internal/Function.h:56:11
  auto t4 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SinusoidFunction", t0.dt());
  CLEAR_DEBUG_MSG();

  DEBUG_MSG("type SimTK::Function_::Step (" __HERE__ ")");
  // defined in SimTKcommon/internal/Function.h:355:21
  auto t5 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("StepFunction", t0.dt());
  CLEAR_DEBUG_MSG();

  auto spline = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SplineFunction", t0.dt());

  auto splinefitter = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SplineFitter");

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Function_
   */
  auto t0_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Function_<T>> wrapped){
    typedef SimTK::Function_<T> WrappedType;

    DEBUG_MSG("T SimTK::Function_::calcValue(const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:138:7
    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::calcDerivative(const SimTK::Array_<int> &, const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:142:7
    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::getArgumentSize() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:146:9
    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::getMaxDerivativeOrder() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:149:9
    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("Function_<T> * SimTK::Function_::clone() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:109:24
    wrapped.method("clone", static_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
    CLEAR_DEBUG_MSG();
  };
  t0.apply<
    SimTK::Function_<double>,
    SimTK::Function_<SimTK::Vec<1>>,
    SimTK::Function_<SimTK::Vec<3>>
    >(t0_decl_methods);

  /* End of SimTK::Function_ class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Function_::Constant
   */

  auto t1_decl_methods = []<typename T> (jlcxx::TypeWrapper<typename SimTK::Function_Constant_<T>> wrapped){
    typedef typename SimTK::Function_Constant_<T> WrappedType;

    DEBUG_MSG("void SimTK::Function_::Constant::Constant(T, int) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:135:14
    wrapped.constructor([] (T t, int i) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Function_<T>::Constant(t, i));
    }, jlcxx::arg("value"), jlcxx::arg("argumentSize")=1);
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Constant::calcValue(const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:138:7
    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Constant::calcDerivative(const SimTK::Array_<int> &, const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:142:7
    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Constant::getArgumentSize() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:146:9
    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Constant::getMaxDerivativeOrder() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:149:9
    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Function_::Constant * SimTK::Function_::Constant::clone() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:153:15
    wrapped.method("clone", reinterpret_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
    CLEAR_DEBUG_MSG();
  };
  t1.apply<SimTK::Function_Constant_<double>>(t1_decl_methods);

  /* End of SimTK::Function_::Constant class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Function_::Linear
   */

  auto t2_decl_methods = []<typename T> (jlcxx::TypeWrapper<typename SimTK::Function_Linear_<T>> wrapped){
    typedef typename SimTK::Function_Linear_<T> WrappedType;

    DEBUG_MSG("void SimTK::Function_::Linear::Linear(const Vector_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:182:14
    wrapped.constructor([] (const SimTK::Vector_<T>& coef) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Function_<T>::Linear(coef));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Linear::calcValue(const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:184:7
    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Linear::calcDerivative(const SimTK::Array_<int> &, const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:192:7
    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Linear::getArgumentSize() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:200:9
    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Linear::getMaxDerivativeOrder() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:203:9
    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Function_::Linear * SimTK::Function_::Linear::clone() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:207:13
    wrapped.method("clone", reinterpret_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
    CLEAR_DEBUG_MSG();
  };
  t2.apply<SimTK::Function_Linear_<double>>(t2_decl_methods);

  /* End of SimTK::Function_::Linear class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Function_::Polynomial
   */

  auto t3_decl_methods = []<typename T> (jlcxx::TypeWrapper<typename SimTK::Function_Polynomial_<T>> wrapped){
    typedef typename SimTK::Function_Polynomial_<T> WrappedType;

    DEBUG_MSG("void SimTK::Function_::Polynomial::Polynomial(const Vector_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:231:5
    wrapped.constructor([] (const SimTK::Vector_<T>& coef) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Function_<T>::Polynomial(coef));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Polynomial::calcValue(const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:233:7
    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Polynomial::calcDerivative(const SimTK::Array_<int> &, const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:241:7
    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Polynomial::getArgumentSize() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:257:9
    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Polynomial::getMaxDerivativeOrder() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:260:9
    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Function_::Polynomial * SimTK::Function_::Polynomial::clone() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:264:17
    wrapped.method("clone", reinterpret_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
    CLEAR_DEBUG_MSG();
  };
  t3.apply<SimTK::Function_Polynomial_<double>>(t3_decl_methods);

  /* End of SimTK::Function_::Polynomial class method wrappers
   **********************************************************************/

  types.method("findRoots!Vec3!Vec2complex", static_cast<void (*)(const SimTK::Vec3 &, SimTK::Vec<2,std::complex<double>> &)>(&SimTK::PolynomialRootFinder::findRoots));
  types.method("findRoots!Vec3complex!Vec2complex", static_cast<void (*)(const SimTK::Vec<3,std::complex<double>> &, SimTK::Vec<2,std::complex<double>> &)>(&SimTK::PolynomialRootFinder::findRoots));
  types.method("findRoots!Vec4!Vec3complex", static_cast<void (*)(const SimTK::Vec4 &, SimTK::Vec<3,std::complex<double>> &)>(&SimTK::PolynomialRootFinder::findRoots));
  types.method("findRoots!Vec4complex!Vec3complex", static_cast<void (*)(const SimTK::Vec<4,std::complex<double>> &, SimTK::Vec<3,std::complex<double>> &)>(&SimTK::PolynomialRootFinder::findRoots));
  types.method("findRoots!Vector!Vector_complex", static_cast<void (*)(const SimTK::Vector &, SimTK::Vector_<std::complex<double>> &)>(&SimTK::PolynomialRootFinder::findRoots));
  types.method("findRoots!Vector_complex!Vector_complex", static_cast<void (*)(const SimTK::Vector_<std::complex<double>> &, SimTK::Vector_<std::complex<double>> &)>(&SimTK::PolynomialRootFinder::findRoots));

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Function_::Sinusoid
   */

  auto t4_decl_methods = []<typename T> (jlcxx::TypeWrapper<typename SimTK::Function_Sinusoid_<T>> wrapped){
    typedef typename SimTK::Function_Sinusoid_<T> WrappedType;

    DEBUG_MSG("void SimTK::Function_::Sinusoid::Sinusoid(const Vector_<T> &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:231:5
    // wrapped.template constructor<SimTK::Real, SimTK::Real, SimTK::Real>();
    wrapped.constructor([] (SimTK::Real ampl, SimTK::Real freq, SimTK::Real phase) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Function_<T>::Sinusoid(ampl, freq, phase));
    }, jlcxx::arg("amplitude"), jlcxx::arg("frequency"), jlcxx::arg("phase")=(SimTK::Real)1);
    CLEAR_DEBUG_MSG();

    wrapped.method("setAmplitude", static_cast<void (WrappedType::*)(SimTK::Real) >(&WrappedType::setAmplitude));
    wrapped.method("setFrequency", static_cast<void (WrappedType::*)(SimTK::Real) >(&WrappedType::setFrequency));
    wrapped.method("setPhase", static_cast<void (WrappedType::*)(SimTK::Real) >(&WrappedType::setPhase));

    wrapped.method("getAmplitude", static_cast<SimTK::Real (WrappedType::*)() const>(&WrappedType::getAmplitude));
    wrapped.method("getFrequency", static_cast<SimTK::Real (WrappedType::*)() const>(&WrappedType::getFrequency));
    wrapped.method("getPhase", static_cast<SimTK::Real (WrappedType::*)() const>(&WrappedType::getPhase));

    DEBUG_MSG("T SimTK::Function_::Sinusoid::calcValue(const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:233:7
    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Sinusoid::calcDerivative(const SimTK::Array_<int> &, const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:241:7
    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Sinusoid::getArgumentSize() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:257:9
    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Sinusoid::getMaxDerivativeOrder() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:260:9
    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Function_::Sinusoid * SimTK::Function_::Sinusoid::clone() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:264:17
    wrapped.method("clone", reinterpret_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
    CLEAR_DEBUG_MSG();
  };
  t4.apply<SimTK::Function_Sinusoid_<double>>(t4_decl_methods);

  /* End of SimTK::Function_::Sinusoid class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Function_::Step
   */

  auto t5_decl_methods = []<typename T> (jlcxx::TypeWrapper<typename SimTK::Function_Step_<T>> wrapped){
    typedef typename SimTK::Function_Step_<T> WrappedType;

    DEBUG_MSG("void SimTK::Function_::Step::Step(const T &, const T &, SimTK::Real, SimTK::Real) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:374:5
    wrapped.constructor([] (const T& y0, const T& y1, SimTK::Real x0, SimTK::Real x1) {
      return reinterpret_cast<WrappedType*>(new typename SimTK::Function_<T>::Step(y0, y1, x0, x1));
    });
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("void SimTK::Function_::Step::setParameters(const T &, const T &, SimTK::Real, SimTK::Real) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:379:10
    wrapped.method("setParameters", static_cast<void (WrappedType::*)(const T &, const T &, SimTK::Real, SimTK::Real) >(&WrappedType::setParameters));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Step::calcValue(const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:386:7
    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("T SimTK::Function_::Step::calcDerivative(const SimTK::Array_<int> &, const SimTK::Vector &) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:399:7
    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Step::getArgumentSize() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:422:9
    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("int SimTK::Function_::Step::getMaxDerivativeOrder() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:423:9
    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));
    CLEAR_DEBUG_MSG();

    DEBUG_MSG("SimTK::Function_::Step * SimTK::Function_::Step::clone() (" __HERE__ ")");
    // defined in SimTKcommon/internal/Function.h:425:11
    wrapped.method("clone", reinterpret_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
    CLEAR_DEBUG_MSG();
  };
  t5.apply<SimTK::Function_Step_<double>>(t5_decl_methods);

  /* End of SimTK::Function_::Step class method wrappers
   **********************************************************************/

  auto spline_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::Spline_<T>> wrapped){
    typedef SimTK::Spline_<T> WrappedType;

    wrapped.template constructor<>();
    wrapped.template constructor<const WrappedType &>();
    wrapped.template constructor<int, const SimTK::Vector&, const SimTK::Vector_<T>&>();

    wrapped.method("set!", static_cast<WrappedType& (WrappedType::*)(const WrappedType &)>(&WrappedType::operator=));

    wrapped.method("calcValue", static_cast<T (WrappedType::*)(SimTK::Real)  const>(&WrappedType::calcValue));

    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(int, const SimTK::Real)  const>(&WrappedType::calcDerivative));

    wrapped.method("getControlPointLocations", static_cast<const SimTK::Vector& (WrappedType::*)() const>(&WrappedType::getControlPointLocations));
    wrapped.method("getControlPointValues", static_cast<const SimTK::Vector_<T>& (WrappedType::*)() const>(&WrappedType::getControlPointValues));
    wrapped.method("getSplineDegree", static_cast<int (WrappedType::*)() const>(&WrappedType::getSplineDegree));

    wrapped.method("calcValue", static_cast<T (WrappedType::*)(const SimTK::Vector &)  const>(&WrappedType::calcValue));

    wrapped.method("calcDerivative", static_cast<T (WrappedType::*)(const SimTK::Array_<int> &, const SimTK::Vector &)  const>(&WrappedType::calcDerivative));

    wrapped.method("getArgumentSize", static_cast<int (WrappedType::*)()  const>(&WrappedType::getArgumentSize));

    wrapped.method("getMaxDerivativeOrder", static_cast<int (WrappedType::*)()  const>(&WrappedType::getMaxDerivativeOrder));

    wrapped.method("clone", reinterpret_cast<WrappedType * (WrappedType::*)()  const>(&WrappedType::clone));
  };
  spline.apply<
    SimTK::Spline_<double>,
    SimTK::Spline_<SimTK::Vec<1>>,
    SimTK::Spline_<SimTK::Vec<3>>
    >(spline_decl_methods);

  auto splinefitter_decl_methods = []<typename T> (jlcxx::TypeWrapper<SimTK::SplineFitter<T>> wrapped){
    typedef SimTK::SplineFitter<T> WrappedType;

    wrapped.method("getSpline", static_cast<const SimTK::Spline_<T>& (WrappedType::*)()>(&WrappedType::getSpline));
    wrapped.method("getSmoothingParameter", static_cast<SimTK::Real (WrappedType::*)() >(&WrappedType::getSmoothingParameter));
    wrapped.method("getMeanSquaredError", static_cast<SimTK::Real (WrappedType::*)() >(&WrappedType::getMeanSquaredError));
    wrapped.method("getDegreesOfFreedom", static_cast<SimTK::Real (WrappedType::*)() >(&WrappedType::getDegreesOfFreedom));
  };
  splinefitter.apply<
    SimTK::SplineFitter<double>,
    SimTK::SplineFitter<SimTK::Vec<1>>,
    SimTK::SplineFitter<SimTK::Vec<3>>
    >(splinefitter_decl_methods);

  types.method("SplineFitter_double!fitFromGCV", &SimTK::SplineFitter<double>::fitFromGCV);
  types.method("SplineFitter_double!fitFromErrorVariance", &SimTK::SplineFitter<double>::fitFromErrorVariance);
  types.method("SplineFitter_double!fitFromDOF", &SimTK::SplineFitter<double>::fitFromDOF);
  types.method("SplineFitter_double!fitForSmoothingParameter", &SimTK::SplineFitter<double>::fitForSmoothingParameter);

  types.method("SplineFitter_Vec1!fitFromGCV", &SimTK::SplineFitter<SimTK::Vec<1>>::fitFromGCV);
  types.method("SplineFitter_Vec1!fitFromErrorVariance", &SimTK::SplineFitter<SimTK::Vec<1>>::fitFromErrorVariance);
  types.method("SplineFitter_Vec1!fitFromDOF", &SimTK::SplineFitter<SimTK::Vec<1>>::fitFromDOF);
  types.method("SplineFitter_Vec1!fitForSmoothingParameter", &SimTK::SplineFitter<SimTK::Vec<1>>::fitForSmoothingParameter);

  types.method("SplineFitter_Vec3!fitFromGCV", &SimTK::SplineFitter<SimTK::Vec<3>>::fitFromGCV);
  types.method("SplineFitter_Vec3!fitFromErrorVariance", &SimTK::SplineFitter<SimTK::Vec<3>>::fitFromErrorVariance);
  types.method("SplineFitter_Vec3!fitFromDOF", &SimTK::SplineFitter<SimTK::Vec<3>>::fitFromDOF);
  types.method("SplineFitter_Vec3!fitForSmoothingParameter", &SimTK::SplineFitter<SimTK::Vec<3>>::fitForSmoothingParameter);

  array_wrapper.template apply<const SimTK::Function *>();

}

}
