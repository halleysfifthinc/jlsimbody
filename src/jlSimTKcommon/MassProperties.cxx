// this file was auto-generated by wrapit v0.1.0-61-g71d8603-dirty
#include "jlsimbody/common.h"

#include "jlSimTKcommon/MassProperties.h"

namespace jlsimbody {

void define_SimTKcommon_MassProperties(jlcxx::Module& types, const ArrayWrapper& array_wrapper){

  // defined in SimTKcommon/internal/MassProperties.h:82:26
  auto inertia = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("Inertia");

  auto t15 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("UnitInertia", inertia.dt());

  auto t2 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SpatialInerta");

  auto t3 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ArticulatedInerta");

  // defined in SimTKcommon/internal/MassProperties.h:85:26
  auto t4 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("MassProperties");

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Inertia_
   */
  auto t1_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Inertia_<P>> wrapped){
    typedef SimTK::Inertia_<P> WrappedType;
    typedef SimTK::Rotation_<P> Rotation;
    typedef SimTK::InverseRotation_<P> InverseRotation;
    wrapped.template constructor<>();
    wrapped.template constructor<const P &>();
    wrapped.template constructor<const SimTK::Vec<3,P>, const P &>();
    // TODO: Replace appropriate constructors/methods when default allocated arguments works
    wrapped.template constructor<const SimTK::Vec<3,P>>();
    wrapped.template constructor<const SimTK::Vec<3,P>, const SimTK::Vec<3,P>>();
    // wrapped.template constructor<const SimTK::Vec<3,P>, const SimTK::Vec<3,P>>(
    //   jlcxx::arg("moments"), jlcxx::arg("products")=zeroVec);
    wrapped.template constructor<const P &, const P &, const P &>();
    wrapped.template constructor<const P &, const P &, const P &, const P &, const P &, const P &>();
    wrapped.template constructor<const SimTK::Mat<3,3,P> &>();

    wrapped.method("setInertia", static_cast<WrappedType & (WrappedType::*)(const SimTK::Vec<3,P> &, const SimTK::Vec<3,P> &) >(&WrappedType::setInertia));
    // wrapped.method("setInertia", static_cast<WrappedType & (WrappedType::*)(const SimTK::Vec<3,P> &, const SimTK::Vec<3,P> &) >(&WrappedType::setInertia),
    //   jlcxx::arg("inertia"), jlcxx::arg("moments"), jlcxx::arg("products")=SimTK::Vec<3,P>(0));
    wrapped.method("setInertia", static_cast<WrappedType & (WrappedType::*)(const P &, const P &, const P &) >(&WrappedType::setInertia));
    wrapped.method("setInertia", static_cast<WrappedType & (WrappedType::*)(const P &, const P &, const P &, const P &, const P &, const P &) >(&WrappedType::setInertia));

    wrapped.method("add!", static_cast<WrappedType & (WrappedType::*)(const WrappedType &) >(&WrappedType::operator+=));
    wrapped.method("sub!", static_cast<WrappedType & (WrappedType::*)(const WrappedType &) >(&WrappedType::operator-=));
    wrapped.method("mult!", static_cast<WrappedType & (WrappedType::*)(const P &) >(&WrappedType::operator*=));
    wrapped.method("div!", static_cast<WrappedType & (WrappedType::*)(const P &) >(&WrappedType::operator/=));

    wrapped.method("shiftToMassCenter", static_cast<WrappedType (WrappedType::*)(const SimTK::Vec<3,P> &, const P &) const>(&WrappedType::shiftToMassCenter));
    wrapped.method("shiftToMassCenterInPlace", static_cast<WrappedType & (WrappedType::*)(const SimTK::Vec<3,P> &, const P &) >(&WrappedType::shiftToMassCenterInPlace));
    wrapped.method("shiftFromMassCenter", static_cast<WrappedType (WrappedType::*)(const SimTK::Vec<3,P> &, const P &) const>(&WrappedType::shiftFromMassCenter));
    wrapped.method("shiftFromMassCenterInPlace", static_cast<WrappedType & (WrappedType::*)(const SimTK::Vec<3,P> &, const P &) >(&WrappedType::shiftFromMassCenterInPlace));

    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const Rotation &) const>(&WrappedType::reexpress));
    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const InverseRotation &) const>(&WrappedType::reexpress));
    wrapped.method("reexpressInPlace", static_cast<WrappedType & (WrappedType::*)(const Rotation &) >(&WrappedType::reexpressInPlace));
    wrapped.method("reexpressInPlace", static_cast<WrappedType & (WrappedType::*)(const InverseRotation &) >(&WrappedType::reexpressInPlace));

    wrapped.method("trace", static_cast<P (WrappedType::*)() const>(&WrappedType::trace));

    wrapped.method("asSymMat33", static_cast<const SimTK::SymMat<3,P> & (WrappedType::*)() const>(&WrappedType::asSymMat33));
    wrapped.method("toMat33", static_cast<SimTK::Mat<3,3,P> (WrappedType::*)() const>(&WrappedType::toMat33));
    wrapped.method("getMoments", static_cast<const SimTK::Vec<3,P> & (WrappedType::*)() const>(&WrappedType::getMoments));
    wrapped.method("getProducts", static_cast<const SimTK::Vec<3,P> & (WrappedType::*)() const>(&WrappedType::getProducts));

    wrapped.method("isapprox", static_cast<bool (WrappedType::*)(const WrappedType &, P) const>(&WrappedType::isNumericallyEqual));

    wrapped.module().set_override_module(jl_base_module);

    // wrapped.method("isnan", static_cast<bool (WrappedType::*)() const>(&WrappedType::isNaN));
    // wrapped.method("isinf", static_cast<bool (WrappedType::*)() const>(&WrappedType::isInf));
    // wrapped.method("isfinite", static_cast<bool (WrappedType::*)() const>(&WrappedType::isFinite));
    wrapped.method("isequal", static_cast<bool (WrappedType::*)(const WrappedType &) const>(&WrappedType::isNumericallyEqual));

    wrapped.module().unset_override_module();
  };
  inertia.apply<SimTK::Inertia_<double>>(t1_decl_methods);

  types.set_override_module(jl_base_module);
  types.method("==", static_cast<bool (*)(const SimTK::Inertia_<double> &, const SimTK::Inertia_<double> &) >(&SimTK::operator==));
  types.method("+", static_cast<SimTK::Inertia_<double> (*)(const SimTK::Inertia_<double> &, const SimTK::Inertia_<double> &) >(&SimTK::operator+));
  types.method("-", static_cast<SimTK::Inertia_<double> (*)(const SimTK::Inertia_<double> &, const SimTK::Inertia_<double> &) >(&SimTK::operator-));

  types.method("*", static_cast<SimTK::Inertia_<double> (*)(const SimTK::Inertia_<double> &, const double &) >(&SimTK::operator*));
  types.method("*", static_cast<SimTK::Vec<3,double> (*)(const SimTK::Inertia_<double> &, const SimTK::Vec<3,double> &) >(&SimTK::operator*));
  types.method("/", static_cast<SimTK::Inertia_<double> (*)(const SimTK::Inertia_<double> &, const double &) >(&SimTK::operator/));
  types.unset_override_module();

  types.method("isValidInertiaMatrix", &SimTK::Inertia_<double>::isValidInertiaMatrix);
  types.method("pointMassAtOrigin", &SimTK::Inertia_<double>::pointMassAtOrigin);
  types.method("pointMassAt", &SimTK::Inertia_<double>::pointMassAt);

  types.method("sphere", &SimTK::Inertia_<double>::sphere);
  types.method("cylinderAlongZ", &SimTK::Inertia_<double>::cylinderAlongZ);
  types.method("cylinderAlongY", &SimTK::Inertia_<double>::cylinderAlongY);
  types.method("cylinderAlongX", &SimTK::Inertia_<double>::cylinderAlongX);

  types.method("brick", static_cast<SimTK::Inertia_<double> (*)(const double &, const double &, const double &)>(&SimTK::Inertia_<double>::brick));
  types.method("brick", static_cast<SimTK::Inertia_<double> (*)(const SimTK::Vec<3,double> &)>(&SimTK::Inertia_<double>::brick));

  types.method("ellipsoid", static_cast<SimTK::Inertia_<double> (*)(const double &, const double &, const double &)>(&SimTK::Inertia_<double>::ellipsoid));
  types.method("ellipsoid", static_cast<SimTK::Inertia_<double> (*)(const SimTK::Vec<3,double> &)>(&SimTK::Inertia_<double>::ellipsoid));

  /* End of SimTK::Inertia_ class method wrappers
   **********************************************************************/

  auto t15_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::UnitInertia_<P>> wrapped){
    typedef SimTK::UnitInertia_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<P>();
    wrapped.template constructor<const SimTK::Vec<3,P> &>();
    wrapped.template constructor<const SimTK::Vec<3,P> &, const SimTK::Vec<3,P> &>();
    // wrapped.template constructor<const SimTK::Vec<3,P> &, const SimTK::Vec<3,P> &>(jlcxx::arg("moments"), jlcxx::arg("products")=SimTK::Vec<3,P>(0));
    wrapped.template constructor<P,P,P>();
    wrapped.template constructor<P,P,P,P,P,P>();
    wrapped.template constructor<const SimTK::Inertia_<P> &>();
    wrapped.template constructor<const SimTK::Mat<3,3,P> &>();

    wrapped.method("setUnitInertia", static_cast<WrappedType & (WrappedType::*)(const P &, const P &, const P &) >(&WrappedType::setUnitInertia));
    wrapped.method("setUnitInertia", static_cast<WrappedType & (WrappedType::*)(const SimTK::Vec<3,P> &, const SimTK::Vec<3,P> &) >(&WrappedType::setUnitInertia));
    wrapped.method("setUnitInertia", static_cast<WrappedType & (WrappedType::*)(const P &, const P &, const P &, const P &, const P &, const P &) >(&WrappedType::setUnitInertia));
    wrapped.method("shiftToCentroid", static_cast<WrappedType (WrappedType::*)(const SimTK::Vec<3,P> &) const>(&WrappedType::shiftToCentroid));
    wrapped.method("shiftToCentroidInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P> &) >(&WrappedType::shiftToCentroidInPlace));
    wrapped.method("shiftFromCentroid", static_cast<WrappedType (WrappedType::*)(const SimTK::Vec<3,P> &) const>(&WrappedType::shiftFromCentroid));
    wrapped.method("shiftFromCentroidInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P> &) >(&WrappedType::shiftFromCentroidInPlace));
    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const SimTK::Rotation_<P> &) const>(&WrappedType::reexpress));
    wrapped.method("reexpressInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Rotation_<P> &) >(&WrappedType::reexpressInPlace));
    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const SimTK::InverseRotation_<P> &) const>(&WrappedType::reexpress));
    wrapped.method("reexpressInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::InverseRotation_<P> &) >(&WrappedType::reexpressInPlace));

    wrapped.method("asUnitInertia", static_cast<const SimTK::Inertia_<P> & (WrappedType::*)() const>(&WrappedType::asUnitInertia));
    wrapped.method("setFromUnitInertia", static_cast<WrappedType & (WrappedType::*)(const SimTK::Inertia_<P> &) >(&WrappedType::setFromUnitInertia));
  };
  t15.apply<SimTK::UnitInertia_<double>>(t15_decl_methods);

  types.method("isValidUnitInertiaMatrix", &SimTK::UnitInertia_<double>::isValidUnitInertiaMatrix);

  auto t2_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::SpatialInertia_<P>> wrapped){
    typedef SimTK::SpatialInertia_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<P, const SimTK::Vec<3,P> &, const SimTK::UnitInertia_<P> &>();

    wrapped.method("setMass", static_cast<WrappedType & (WrappedType::*)(P) >(&WrappedType::setMass));
    wrapped.method("setMassCenter", static_cast<WrappedType & (WrappedType::*)(const SimTK::Vec<3,P> &) >(&WrappedType::setMassCenter));
    wrapped.method("setUnitInertia", static_cast<WrappedType & (WrappedType::*)(const SimTK::UnitInertia_<P> &) >(&WrappedType::setUnitInertia));
    wrapped.method("getMass", static_cast<P (WrappedType::*)() const>(&WrappedType::getMass));
    wrapped.method("getMassCenter", static_cast<const SimTK::Vec<3,P> & (WrappedType::*)() const>(&WrappedType::getMassCenter));
    wrapped.method("getUnitInertia", static_cast<const SimTK::UnitInertia_<P> & (WrappedType::*)() const>(&WrappedType::getUnitInertia));

    wrapped.method("calcMassMoment", static_cast<SimTK::Vec<3,P> (WrappedType::*)() const>(&WrappedType::calcMassMoment));
    wrapped.method("calcInertia", static_cast<SimTK::Inertia_<P> (WrappedType::*)() const>(&WrappedType::calcInertia));

    wrapped.method("add!", static_cast<WrappedType & (WrappedType::*)(const WrappedType &) >(&WrappedType::operator+=));
    wrapped.method("sub!", static_cast<WrappedType & (WrappedType::*)(const WrappedType &) >(&WrappedType::operator-=));
    wrapped.method("mult!", static_cast<WrappedType & (WrappedType::*)(const P &) >(&WrappedType::operator*=));
    wrapped.method("div!", static_cast<WrappedType & (WrappedType::*)(const P &) >(&WrappedType::operator/=));

    wrapped.module().set_override_module(jl_base_module);
    wrapped.method("*", static_cast<SimTK::SpatialVec (WrappedType::*)(const SimTK::SpatialVec &) const>(&WrappedType::operator*));
    wrapped.module().unset_override_module();

    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const SimTK::Rotation_<P> &) const>(&WrappedType::reexpress));
    wrapped.method("reexpressInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Rotation_<P> &) >(&WrappedType::reexpressInPlace));
    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const SimTK::InverseRotation_<P> &) const>(&WrappedType::reexpress));
    wrapped.method("reexpressInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::InverseRotation_<P> &) >(&WrappedType::reexpressInPlace));
    wrapped.method("shift", static_cast<WrappedType (WrappedType::*)(const SimTK::Vec<3,P> &) const>(&WrappedType::shift));
    wrapped.method("shiftInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P> &) >(&WrappedType::shiftInPlace));
    wrapped.method("transform", static_cast<WrappedType (WrappedType::*)(const SimTK::Transform_<P> &) const>(&WrappedType::transform));
    wrapped.method("transformInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Transform_<P> &) >(&WrappedType::transformInPlace));
    wrapped.method("transform", static_cast<WrappedType (WrappedType::*)(const SimTK::InverseTransform_<P> &) const>(&WrappedType::transform));
    wrapped.method("transformInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::InverseTransform_<P> &) >(&WrappedType::transformInPlace));

    wrapped.method("toSpatialMat", static_cast<const SimTK::Mat<2,2,SimTK::Mat<3,3,P>> (WrappedType::*)() const>(&WrappedType::toSpatialMat));
  };
  t2.apply<SimTK::SpatialInertia_<double>>(t2_decl_methods);

  types.set_override_module(jl_base_module);
  types.method("+", static_cast<SimTK::SpatialInertia_<double> (*)(const SimTK::SpatialInertia_<double> &, const SimTK::SpatialInertia_<double> &) >(&SimTK::operator+));
  types.method("-", static_cast<SimTK::SpatialInertia_<double> (*)(const SimTK::SpatialInertia_<double> &, const SimTK::SpatialInertia_<double> &) >(&SimTK::operator-));
  types.unset_override_module();

  array_wrapper.template apply<SimTK::SpatialInertia_<double>, int>();

  auto t3_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::ArticulatedInertia_<P>> wrapped){
    typedef SimTK::ArticulatedInertia_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::SymMat<3,P> &, const SimTK::Mat<3,3,P> &, const SimTK::SymMat<3,P> &>();
    wrapped.template constructor<const SimTK::SpatialInertia_<P> &>();

    wrapped.method("setMass", static_cast<WrappedType & (WrappedType::*)(const SimTK::SymMat<3,P> &) >(&WrappedType::setMass));
    wrapped.method("setMassMoment", static_cast<WrappedType & (WrappedType::*)(const SimTK::Mat<3,3,P> &) >(&WrappedType::setMassMoment));
    wrapped.method("setInertia", static_cast<WrappedType & (WrappedType::*)(const SimTK::SymMat<3,P> &) >(&WrappedType::setInertia));
    wrapped.method("getMass", static_cast<const SimTK::SymMat<3,P> & (WrappedType::*)() const>(&WrappedType::getMass));
    wrapped.method("getMassMoment", static_cast<const SimTK::Mat<3,3,P> & (WrappedType::*)() const>(&WrappedType::getMassMoment));
    wrapped.method("getInertia", static_cast<const SimTK::SymMat<3,P> & (WrappedType::*)() const>(&WrappedType::getInertia));

    wrapped.method("add!", static_cast<WrappedType & (WrappedType::*)(const WrappedType &) >(&WrappedType::operator+=));
    wrapped.method("sub!", static_cast<WrappedType & (WrappedType::*)(const WrappedType &) >(&WrappedType::operator-=));

    wrapped.module().set_override_module(jl_base_module);
    wrapped.method("*", static_cast<SimTK::SpatialVec (WrappedType::*)(const SimTK::SpatialVec &) const>(&WrappedType::operator*));
    wrapped.method("*", static_cast<SimTK::Mat<2, 1, SimTK::Vec<3,P>> (WrappedType::*)(const SimTK::Mat<2, 1, SimTK::Vec<3,P>> &) const>(&WrappedType::operator*));
    wrapped.method("*", static_cast<SimTK::Mat<2, 2, SimTK::Vec<3,P>> (WrappedType::*)(const SimTK::Mat<2, 2, SimTK::Vec<3,P>> &) const>(&WrappedType::operator*));
    wrapped.method("*", static_cast<SimTK::Mat<2, 3, SimTK::Vec<3,P>> (WrappedType::*)(const SimTK::Mat<2, 3, SimTK::Vec<3,P>> &) const>(&WrappedType::operator*));
    wrapped.method("*", static_cast<SimTK::Mat<2, 4, SimTK::Vec<3,P>> (WrappedType::*)(const SimTK::Mat<2, 4, SimTK::Vec<3,P>> &) const>(&WrappedType::operator*));
    wrapped.method("*", static_cast<SimTK::Mat<2, 5, SimTK::Vec<3,P>> (WrappedType::*)(const SimTK::Mat<2, 5, SimTK::Vec<3,P>> &) const>(&WrappedType::operator*));
    wrapped.method("*", static_cast<SimTK::Mat<2, 6, SimTK::Vec<3,P>> (WrappedType::*)(const SimTK::Mat<2, 6, SimTK::Vec<3,P>> &) const>(&WrappedType::operator*));
    wrapped.module().unset_override_module();

    wrapped.method("shift", static_cast<WrappedType (WrappedType::*)(const SimTK::Vec<3,P> &) const>(&WrappedType::shift));
    wrapped.method("shiftInPlace", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P> &) >(&WrappedType::shiftInPlace));

    wrapped.method("toSpatialMat", static_cast<const SimTK::Mat<2,2,SimTK::Mat<3,3,P>> (WrappedType::*)() const>(&WrappedType::toSpatialMat));
  };
  t3.apply<SimTK::ArticulatedInertia_<double>>(t3_decl_methods);

  types.set_override_module(jl_base_module);
  types.method("+", static_cast<SimTK::ArticulatedInertia_<double> (*)(const SimTK::ArticulatedInertia_<double> &, const SimTK::ArticulatedInertia_<double> &) >(&SimTK::operator+));
  types.method("-", static_cast<SimTK::ArticulatedInertia_<double> (*)(const SimTK::ArticulatedInertia_<double> &, const SimTK::ArticulatedInertia_<double> &) >(&SimTK::operator-));
  types.unset_override_module();

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::MassProperties_
   */
  auto t4_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::MassProperties_<P>> wrapped){
    typedef SimTK::MassProperties_<P> WrappedType;
    typedef SimTK::Inertia_<P> Inertia;
    typedef SimTK::Transform_<P> Transform;
    typedef SimTK::Rotation_<P> Rotation;
    typedef SimTK::Vec<3,P> Vec3P;
    wrapped.template constructor<>();
    wrapped.template constructor<const P &, const Vec3P &, const Inertia &>();

    wrapped.method("setMassProperties", static_cast<WrappedType & (WrappedType::*)(const P &, const Vec3P &, const Inertia &) >(&WrappedType::setMassProperties));
    wrapped.method("setMassProperties", static_cast<WrappedType & (WrappedType::*)(const P &, const Vec3P &, const SimTK::UnitInertia &) >(&WrappedType::setMassProperties));
    wrapped.method("getMass", static_cast<const P & (WrappedType::*)() const>(&WrappedType::getMass));
    wrapped.method("getMassCenter", static_cast<const Vec3P & (WrappedType::*)() const>(&WrappedType::getMassCenter));
    wrapped.method("getUnitInertia", static_cast<const SimTK::UnitInertia & (WrappedType::*)() const>(&WrappedType::getUnitInertia));
    wrapped.method("calcInertia", static_cast<const Inertia (WrappedType::*)() const>(&WrappedType::calcInertia));

    wrapped.method("calcCentralInertia", static_cast<Inertia (WrappedType::*)() const>(&WrappedType::calcCentralInertia));
    wrapped.method("calcShiftedInertia", static_cast<Inertia (WrappedType::*)(const Vec3P &) const>(&WrappedType::calcShiftedInertia));
    wrapped.method("calcTransformedInertia", static_cast<Inertia (WrappedType::*)(const Transform &) const>(&WrappedType::calcTransformedInertia));

    wrapped.method("calcShiftedMassProps", static_cast<WrappedType (WrappedType::*)(const Vec3P &) const>(&WrappedType::calcShiftedMassProps));
    wrapped.method("calcTransformedMassProps", static_cast<WrappedType (WrappedType::*)(const Transform &) const>(&WrappedType::calcTransformedMassProps));

    wrapped.method("reexpress", static_cast<WrappedType (WrappedType::*)(const Rotation &) const>(&WrappedType::reexpress));

    wrapped.method("isExactlyMassless", static_cast<bool (WrappedType::*)() const>(&WrappedType::isExactlyMassless));
    wrapped.method("isNearlyMassless", static_cast<bool (WrappedType::*)(const P &) const>(&WrappedType::isNearlyMassless));
    wrapped.method("isExactlyCentral", static_cast<bool (WrappedType::*)() const>(&WrappedType::isExactlyCentral));
    wrapped.method("isNearlyCentral", static_cast<bool (WrappedType::*)(const P &) const>(&WrappedType::isNearlyCentral));

    wrapped.method("toSpatialMat", static_cast<SimTK::Mat<2,2,SimTK::Mat<3,3,P>> (WrappedType::*)() const>(&WrappedType::toSpatialMat));
    wrapped.method("toMat66", static_cast<SimTK::Mat<6,6,P> (WrappedType::*)() const>(&WrappedType::toMat66));

  };
  t4.apply<SimTK::MassProperties_<double>>(t4_decl_methods);

  /* End of SimTK::MassProperties_ class method wrappers
   **********************************************************************/

}

}
