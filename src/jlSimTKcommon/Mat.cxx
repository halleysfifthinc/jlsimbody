// this file was auto-generated by wrapit v0.1.0-61-g71d8603-dirty
#include "jlsimbody/common.h"
#include "jlcxx/tuple.hpp"

#include "jlSimTKcommon/Mat.h"

namespace jlsimbody {

void define_SimTKcommon_Mat(jlcxx::Module& types){

  // defined in SimTKcommon/internal/Mat.h:97:58
  auto t0 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>, jlcxx::TypeVar<2>, jlcxx::TypeVar<3>, jlcxx::TypeVar<4>, jlcxx::TypeVar<5>>>("SimTK!Mat");

  auto t1 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>, jlcxx::TypeVar<2>, jlcxx::TypeVar<3>>>("SimTK!SymMat");

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Mat
   */
  auto t0_decl_methods = []<int M, int N, typename ELT, int CS, int RS> (jlcxx::TypeWrapper<SimTK::Mat<M, N, ELT, CS, RS>> wrapped){
    typedef SimTK::Mat<M, N, ELT, CS, RS> WrappedType;
    wrapped.template constructor<>();

    DEBUG_MSG("Adding wrapper for void SimTK::Mat::Mat<M, N, ELT, CS, RS>(int) (" __HERE__ ")");
    // defined in SimTKcommon/internal/Mat.h:376:14
    wrapped.template constructor<int>();

    DEBUG_MSG("Adding wrapper for void SimTK::Mat::setToNaN() (" __HERE__ ")");
    // signature to use in the veto list: void SimTK::Mat::setToNaN()
    // defined in SimTKcommon/internal/Mat.h:904:10
    wrapped.method("setToNaN", static_cast<void (WrappedType::*)() >(&WrappedType::setToNaN));

    DEBUG_MSG("Adding wrapper for void SimTK::Mat::setToZero() (" __HERE__ ")");
    // signature to use in the veto list: void SimTK::Mat::setToZero()
    // defined in SimTKcommon/internal/Mat.h:909:10
    wrapped.method("setToZero", static_cast<void (WrappedType::*)() >(&WrappedType::setToZero));

    DEBUG_MSG("Adding wrapper for bool SimTK::Mat::isNaN() (" __HERE__ ")");
    // signature to use in the veto list: bool SimTK::Mat::isNaN()
    // defined in SimTKcommon/internal/Mat.h:1092:10
    wrapped.method("isNaN", static_cast<bool (WrappedType::*)()  const>(&WrappedType::isNaN));

    DEBUG_MSG("Adding wrapper for bool SimTK::Mat::isInf() (" __HERE__ ")");
    // signature to use in the veto list: bool SimTK::Mat::isInf()
    // defined in SimTKcommon/internal/Mat.h:1101:10
    wrapped.method("isInf", static_cast<bool (WrappedType::*)()  const>(&WrappedType::isInf));

    DEBUG_MSG("Adding wrapper for bool SimTK::Mat::isFinite() (" __HERE__ ")");
    // signature to use in the veto list: bool SimTK::Mat::isFinite()
    // defined in SimTKcommon/internal/Mat.h:1114:10
    wrapped.method("isFinite", static_cast<bool (WrappedType::*)()  const>(&WrappedType::isFinite));

    DEBUG_MSG("Adding wrapper for std::string SimTK::Mat::toString() (" __HERE__ ")");
    // signature to use in the veto list: std::string SimTK::Mat::toString()
    // defined in SimTKcommon/internal/Mat.h:1219:17
    wrapped.method("toString", static_cast<std::string (WrappedType::*)()  const>(&WrappedType::toString));
  };
  t0.apply<SimTK::Mat<1, 1, double, 1, 1>, SimTK::Mat<1, 2, SimTK::Row<3, double, 1>, 1, 2>, SimTK::Mat<2, 1, SimTK::Vec<3, double, 1>, 2, 1>, SimTK::Mat<2, 2, double, 2, 1>, SimTK::Mat<2, 2, SimTK::Row<3, double, 1>, 1, 2>, SimTK::Mat<2, 2, SimTK::Vec<3, double, 1>, 2, 1>, SimTK::Mat<2, 2, std::complex<double>, 2, 1>, SimTK::Mat<2, 3, SimTK::Vec<3, double, 1>, 2, 1>, SimTK::Mat<2, 4, SimTK::Vec<3, double, 1>, 2, 1>, SimTK::Mat<2, 5, SimTK::Vec<3, double, 1>, 2, 1>, SimTK::Mat<2, 6, SimTK::Vec<3, double, 1>, 2, 1>, SimTK::Mat<3, 2, SimTK::Row<3, double, 1>, 1, 2>, SimTK::Mat<3, 3, double, 1, 3>, SimTK::Mat<3, 3, double, 3, 1>, SimTK::Mat<3, 3, std::complex<double>, 3, 1>, SimTK::Mat<2, 2, SimTK::Mat<3, 3, double, 3, 1>, 2, 1>, SimTK::Mat<3, 4, double, 3, 1>, SimTK::Mat<4, 2, SimTK::Row<3, double, 1>, 1, 2>, SimTK::Mat<4, 4, double, 4, 1>, SimTK::Mat<4, 4, SimTK::Vec<3, double, 1>, 4, 1>, SimTK::Mat<4, 4, std::complex<double>, 4, 1>, SimTK::Mat<5, 2, SimTK::Row<3, double, 1>, 1, 2>, SimTK::Mat<5, 5, double, 5, 1>, SimTK::Mat<5, 5, std::complex<double>, 5, 1>, SimTK::Mat<6, 2, SimTK::Row<3, double, 1>, 1, 2>, SimTK::Mat<6, 3, double, 6, 1>, SimTK::Mat<6, 6, double, 6, 1>>(t0_decl_methods);

  /* End of SimTK::Mat class method wrappers
   **********************************************************************/

  /* Begin adding SimTK::SymMat class method wrappers
   **********************************************************************/

  auto t1_decl_methods = []<int M, typename ELT, int RS> (jlcxx::TypeWrapper<SimTK::SymMat<M, ELT, RS>> wrapped){
    typedef SimTK::SymMat<M, ELT, RS> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const WrappedType &>();
    wrapped.template constructor<const SimTK::Mat<M,M,ELT,M,RS> &>();
    wrapped.template constructor<const ELT &>();

    wrapped.method("setFromLower", static_cast<WrappedType & (WrappedType::*)(const SimTK::Mat<M,M,ELT,M,RS> &)>(&WrappedType::setFromLower));
    wrapped.method("setFromUpper", static_cast<WrappedType & (WrappedType::*)(const SimTK::Mat<M,M,ELT,M,RS> &)>(&WrappedType::setFromUpper));
    wrapped.method("setFromSymmetric", static_cast<WrappedType & (WrappedType::*)(const SimTK::Mat<M,M,ELT,M,RS> &)>(&WrappedType::setFromSymmetric));

    wrapped.method("cppgetindex", static_cast<ELT & (WrappedType::*)(int, int)>(&WrappedType::operator()));
    wrapped.method("slice_row", static_cast<SimTK::Row<M,ELT,RS> (WrappedType::*)(int) const>(&WrappedType::row));
    wrapped.method("slice_col", static_cast<SimTK::Vec<M,ELT,RS> (WrappedType::*)(int) const>(&WrappedType::col));
    
    wrapped.module().set_override_module(jl_base_module);
    wrapped.method("size", []() { std::make_tuple(M, M); });
    wrapped.module().unset_override_module();
  };
  t1.apply<SimTK::SymMat<3,double,1>>(t1_decl_methods);

  /* End of SimTK::SymMat class method wrappers
   **********************************************************************/

  // wrapped.template constructor<const SimTK::SymMat<M,ELT,RS> &>();

  DEBUG_MSG("End of wrapper definitions");

}
}
