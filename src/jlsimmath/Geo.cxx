// this file was auto-generated by wrapit v0.1.0-61-g71d8603-dirty
#include <type_traits>
#include "jlcxx/jlcxx.hpp"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

#include "jlsimmath/Geo.h"

#ifdef VERBOSE_IMPORT
#  define DEBUG_MSG(a) std::cerr << a << "\n"
#else
#  define DEBUG_MSG(a)
#endif
#define __HERE__  __FILE__ ":" QUOTE2(__LINE__)
#define QUOTE(arg) #arg
#define QUOTE2(arg) QUOTE(arg)

namespace jlsimbody{

void define_simbody_Geo(jlcxx::Module& types){

  // DEBUG_MSG("Adding wrapper for type SimTK::Geo (" __HERE__ ")");
  // // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:53:28
  // auto t0 = types.add_type<SimTK::Geo>("SimTK!Geo");
  // t0.template constructor<>(/*finalize=*/true);

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:55:26
  auto t1 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Point_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:56:26
  auto t2 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Sphere_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:57:26
  auto t3 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!LineSeg_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:61:26
  auto t7 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Box_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:62:26
  auto t8 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!AlignedBox_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:63:26
  auto t9 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!OrientedBox_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:64:26
  auto t10 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Triangle_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:65:26
  auto t11 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!CubicHermiteCurve_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:66:26
  auto t12 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!BicubicHermitePatch_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:67:26
  auto t13 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!CubicBezierCurve_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:68:26
  auto t14 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!BicubicBezierPatch_");

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Sphere_
   */
  auto t2_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Sphere_<P>> wrapped){
    typedef SimTK::Geo::Sphere_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>&, P>(/*finalize=*/true);

    wrapped.method("setRadius", static_cast<WrappedType& (WrappedType::*)(P)>(&WrappedType::setRadius));
    wrapped.method("getRadius", static_cast<P (WrappedType::*)() const>(&WrappedType::getRadius));
    wrapped.method("updRadius", static_cast<P& (WrappedType::*)()>(&WrappedType::updRadius));

    wrapped.method("setCenter", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setCenter));
    wrapped.method("getCenter", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getCenter));
    wrapped.method("updCenter", static_cast<SimTK::Vec<3,P>& (WrappedType::*)()>(&WrappedType::updCenter));

    wrapped.method("scaleBy", static_cast<WrappedType& (WrappedType::*)(P)>(&WrappedType::scaleBy));
    wrapped.method("stretchBoundary", static_cast<WrappedType& (WrappedType::*)()>(&WrappedType::stretchBoundary));
    wrapped.method("findVolume", static_cast<P (WrappedType::*)() const>(&WrappedType::findVolume));
    wrapped.method("findArea", static_cast<P (WrappedType::*)() const>(&WrappedType::findArea));

    wrapped.method("isPointOutside", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::isPointOutside));
    wrapped.method("isPointOutside", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&, P) const>(&WrappedType::isPointOutside));
  };
  t2.apply<SimTK::Geo::Sphere_<double>>(t2_decl_methods);

  /* End of SimTK::Geo::Sphere_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::LineSeg_
   */
  auto t3_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::LineSeg_<P>> wrapped){
    typedef SimTK::Geo::LineSeg_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&>(/*finalize=*/true);

    wrapped.method("setEndpoints", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&)>(&WrappedType::setEndpoints));
    wrapped.method("setEndpoint", static_cast<WrappedType& (WrappedType::*)(int, const SimTK::Vec<3,P>&)>(&WrappedType::setEndpoint));
    wrapped.method("getEndpoint", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)(int) const>(&WrappedType::getEndpoint));
    wrapped.method("updEndpoint", static_cast<SimTK::Vec<3,P>& (WrappedType::*)(int)>(&WrappedType::updEndpoint));
    wrapped.method("calcLength", static_cast<P (WrappedType::*)() const>(&WrappedType::calcLength));
    wrapped.method("calcLengthSqr", static_cast<P (WrappedType::*)() const>(&WrappedType::calcLengthSqr));
    wrapped.method("findPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::findPoint));
    wrapped.method("findMidpoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)() const>(&WrappedType::findMidpoint));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("findDistanceToPoint", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceToPoint));
    wrapped.method("findDistanceToPointSqr", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceToPointSqr));

    wrapped.module().set_override_module(jl_base_module);
    
    wrapped.method("getindex", [](const WrappedType& self, int i) {
      return self[i-1];
    });
    
    wrapped.module().unset_override_module();
  };
  t3.apply<SimTK::Geo::LineSeg_<double>>(t3_decl_methods);

  /* End of SimTK::Geo::LineSeg_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Box_
   */
  auto t7_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Box_<P>> wrapped){
    typedef SimTK::Geo::Box_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>&>(/*finalize=*/true);

    wrapped.method("setHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setHalfLengths));
    wrapped.method("addToHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::addToHalfLengths));
    wrapped.method("getOrderedHalfLength", static_cast<P (WrappedType::*)(int) const>(&WrappedType::getOrderedHalfLength));
    wrapped.method("getOrderedAxis", static_cast<SimTK::CoordinateAxis (WrappedType::*)(int) const>(&WrappedType::getOrderedAxis));

    wrapped.method("findVolume", static_cast<P (WrappedType::*)() const>(&WrappedType::findVolume));
    wrapped.method("findArea", static_cast<P (WrappedType::*)() const>(&WrappedType::findArea));
    wrapped.method("containsPoint", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::containsPoint));
    wrapped.method("findClosestPointOfSolidBox", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&, bool&) const>(&WrappedType::findClosestPointOfSolidBox));
    wrapped.method("findClosestPointOnSurface", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&, bool&) const>(&WrappedType::findClosestPointOnSurface));
    wrapped.method("findDistanceSqrToPoint", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceSqrToPoint));
    wrapped.method("findSupportPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findSupportPoint));
    wrapped.method("findDistanceSqrToSphere", static_cast<P (WrappedType::*)(const SimTK::Geo::Sphere_<P>&) const>(&WrappedType::findDistanceSqrToSphere));
    // wrapped.method("findDistanceSqrToAlignedBox", static_cast<P (WrappedType::*)(const SimTK::Geo::AlignedBox_<P>&) const>(&WrappedType::findDistanceSqrToAlignedBox));
    
    wrapped.method("intersectsSphere", static_cast<bool (WrappedType::*)(const SimTK::Geo::Sphere_<P>&) const>(&WrappedType::intersectsSphere));
    // wrapped.method("intersectsAlignedBox", static_cast<bool (WrappedType::*)(const SimTK::Geo::AlignedBox_<P>&) const>(&WrappedType::intersectsAlignedBox));
    // wrapped.method("intersectsOrientedBox", static_cast<bool (WrappedType::*)(const SimTK::Geo::OrientedBox_<P>&) const>(&WrappedType::intersectsOrientedBox));
    // wrapped.method("mayIntersectOrientedBox", static_cast<bool (WrappedType::*)(const SimTK::Geo::OrientedBox_<P>&) const>(&WrappedType::mayIntersectOrientedBox));

    wrapped.method("getVertexPos", static_cast<SimTK::Vec<3,P> (WrappedType::*)(int) const>(&WrappedType::getVertexPos));
    wrapped.method("findSupportVertex", static_cast<int (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findSupportVertex));
    wrapped.method("getVertexNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getVertexNormal));
    wrapped.method("getEdgeCenter", static_cast<SimTK::Vec<3,P> (WrappedType::*)(int) const>(&WrappedType::getEdgeCenter));
    wrapped.method("getEdgeNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getEdgeNormal));
    wrapped.method("getEdgeCoordinateDirection", static_cast<SimTK::CoordinateDirection (WrappedType::*)(int) const>(&WrappedType::getEdgeCoordinateDirection));
    wrapped.method("getEdgeDirection", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getEdgeDirection));

    wrapped.method("getFaceCoordinateDirection", static_cast<SimTK::CoordinateDirection (WrappedType::*)(int) const>(&WrappedType::getFaceCoordinateDirection));
    wrapped.method("getFaceCenter", static_cast<SimTK::Vec<3,P> (WrappedType::*)(int) const>(&WrappedType::getFaceCenter));
    wrapped.method("getFaceNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getFaceNormal));
    wrapped.method("getFaceVertices", static_cast<void (WrappedType::*)(int, int[4]) const>(&WrappedType::getFaceVertices));
    wrapped.method("getVertexFaces", static_cast<void (WrappedType::*)(int, int[3], int[3]) const>(&WrappedType::getVertexFaces));
    wrapped.method("getEdgeVertices", static_cast<void (WrappedType::*)(int, int[2]) const>(&WrappedType::getEdgeVertices));
    wrapped.method("getVertexEdges", static_cast<void (WrappedType::*)(int, int[3], int[3]) const>(&WrappedType::getVertexEdges));
    wrapped.method("getFaceEdges", static_cast<void (WrappedType::*)(int, int[4]) const>(&WrappedType::getFaceEdges));
    wrapped.method("getEdgeFaces", static_cast<void (WrappedType::*)(int, int[2], int[2]) const>(&WrappedType::getEdgeFaces));
    wrapped.method("getNumVertices", []() { return 8; });
    wrapped.method("getNumEdges", []() { return 12; });
    wrapped.method("getNumFaces", []() { return 6; });

  };
  t7.apply<SimTK::Geo::Box_<double>>(t7_decl_methods);

  /* End of SimTK::Geo::Box_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::AlignedBox_
   */
  auto t8_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::AlignedBox_<P>> wrapped){
    typedef SimTK::Geo::AlignedBox_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Geo::Box_<P>&>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&>(/*finalize=*/true);

    wrapped.method("setCenter", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setCenter));
    wrapped.method("setHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setHalfLengths));
    wrapped.method("getCenter", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getCenter));
    wrapped.method("updCenter", static_cast<SimTK::Vec<3,P>& (WrappedType::*)()>(&WrappedType::updCenter));
    wrapped.method("getHalfLengths", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getHalfLengths));
    wrapped.method("getBox", static_cast<const SimTK::Geo::Box_<P>& (WrappedType::*)() const>(&WrappedType::getBox));
    wrapped.method("updBox", static_cast<SimTK::Geo::Box_<P>& (WrappedType::*)()>(&WrappedType::updBox));
    wrapped.method("containsPoint", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::containsPoint));
    wrapped.method("stretchBoundary", static_cast<WrappedType& (WrappedType::*)()>(&WrappedType::stretchBoundary));
  };
  t8.apply<SimTK::Geo::AlignedBox_<double>>(t8_decl_methods);

  // types.method("intersectsAlignedBox", static_cast<bool (*)(const SimTK::Geo::Box&, const SimTK::Geo::AlignedBox&)>(&SimTK::Geo::Box::intersectsAlignedBox));
  types.method("intersectsAlignedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::AlignedBox& abox) -> bool {
    return box.intersectsAlignedBox(abox);
  });
  // wrapped.method("findDistanceSqrToAlignedBox", static_cast<P (WrappedType::*)(const SimTK::Geo::AlignedBox_<P>&) const>(&WrappedType::findDistanceSqrToAlignedBox));
  types.method("findDistanceSqrToAlignedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::AlignedBox& abox) -> double {
    return box.findDistanceSqrToAlignedBox(abox);
  });

  /* End of SimTK::Geo::AlignedBox_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::OrientedBox_
   */
  auto t9_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::OrientedBox_<P>> wrapped){
    typedef SimTK::Geo::OrientedBox_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Transform_<P>&, const SimTK::Geo::Box_<P>&>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Transform_<P>&, const SimTK::Vec<3,P>&>(/*finalize=*/true);

    wrapped.method("setTransform", static_cast<WrappedType& (WrappedType::*)(const SimTK::Transform_<P>&)>(&WrappedType::setTransform));
    wrapped.method("setHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setHalfLengths));
    wrapped.method("getCenter", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getCenter));
    wrapped.method("updCenter", static_cast<SimTK::Vec<3,P>& (WrappedType::*)()>(&WrappedType::updCenter));
    wrapped.method("getOrientation", static_cast<const SimTK::Rotation_<P>& (WrappedType::*)() const>(&WrappedType::getOrientation));
    wrapped.method("updOrientation", static_cast<SimTK::Rotation_<P>& (WrappedType::*)()>(&WrappedType::updOrientation));
    wrapped.method("getTransform", static_cast<const SimTK::Transform_<P>& (WrappedType::*)() const>(&WrappedType::getTransform));
    wrapped.method("updTransform", static_cast<SimTK::Transform_<P>& (WrappedType::*)()>(&WrappedType::updTransform));
    wrapped.method("getHalfLengths", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getHalfLengths));
    wrapped.method("getBox", static_cast<const SimTK::Geo::Box_<P>& (WrappedType::*)() const>(&WrappedType::getBox));
    wrapped.method("updBox", static_cast<SimTK::Geo::Box_<P>& (WrappedType::*)()>(&WrappedType::updBox));
    wrapped.method("containsPoint", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::containsPoint));
    wrapped.method("stretchBoundary", static_cast<WrappedType& (WrappedType::*)()>(&WrappedType::stretchBoundary));
  };
  t9.apply<SimTK::Geo::OrientedBox_<double>>(t9_decl_methods);

  // wrapped.method("intersectsOrientedBox", static_cast<bool (SimTK::Geo::Box_<P>::*)(const WrappedType&) const>(&SimTK::Geo::Box_<P>::intersectsOrientedBox));
  // wrapped.method("mayIntersectOrientedBox", static_cast<bool (SimTK::Geo::Box_<P>::*)(const WrappedType&) const>(&SimTK::Geo::Box_<P>::mayIntersectOrientedBox));
  types.method("intersectsOrientedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::OrientedBox& obox) -> bool {
    return box.intersectsOrientedBox(obox);
  });
  types.method("mayIntersectOrientedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::OrientedBox& obox) -> bool {
    return box.mayIntersectOrientedBox(obox);
  });

  /* End of SimTK::Geo::OrientedBox_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Point_
   */
  auto t1_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Point_<P>> wrapped){
    typedef SimTK::Geo::Point_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);

    wrapped.method("setLocation", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setLocation));
    wrapped.method("getLocation", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getLocation));
    wrapped.method("calcDistance", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::calcDistance));
    wrapped.method("findDistanceSqr", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceSqr));
  };
  t1.apply<SimTK::Geo::Point_<double>>(t1_decl_methods);

  typedef SimTK::Vec3 Vec3;
  types.method("calcDistance", static_cast<double (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::calcDistance));
  types.method("findDistanceSqr", static_cast<double (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::findDistanceSqr));
  types.method("findMidpoint", static_cast<Vec3 (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::findMidpoint));
  types.method("pointsAreNumericallyCoincident", static_cast<bool (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::pointsAreNumericallyCoincident));
  types.method("pointsAreNumericallyCoincident", static_cast<bool (*)(const Vec3 &, const Vec3 &, double)>(&SimTK::Geo::Point::pointsAreNumericallyCoincident));
  types.method("findSupportPoint", static_cast<void (*)(const SimTK::Array_<Vec3> &, const SimTK::UnitVec<double,1> &, int &, double &)>(&SimTK::Geo::Point::findSupportPoint));
  // types.method("findSupportPointIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, const SimTK::UnitVec<double,1> &, int &, double &)>(&SimTK::Geo::Point::findSupportPointIndirect));
  types.method("findExtremePoints", static_cast<void (*)(const SimTK::Array_<Vec3> &, const SimTK::UnitVec<double,1> &, int &, int &, double &, double &)>(&SimTK::Geo::Point::findExtremePoints));
  // types.method("findExtremePointsIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, const SimTK::UnitVec<double,1> &, int &, int &, double &, double &)>(&SimTK::Geo::Point::findExtremePointsIndirect));
  types.method("calcCentroid", static_cast<Vec3 (*)(const SimTK::Array_<Vec3> &)>(&SimTK::Geo::Point::calcCentroid));
  // types.method("calcCentroidIndirect", static_cast<Vec3 (*)(const SimTK::Array_<const Vec3 *> &)>(&SimTK::Geo::Point::calcCentroidIndirect));
  // types.method("calcCovariance", static_cast<void (*)(const SimTK::Array_<Vec3> &, Vec3 &, SimTK::SymMat<3,3,double> &)>(&SimTK::Geo::Point::calcCovariance));
  // types.method("calcCovarianceIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, Vec3 &, SimTK::SymMat<3,3,double> &)>(&SimTK::Geo::Point::calcCovarianceIndirect));
  types.method("calcPrincipalComponents", static_cast<void (*)(const SimTK::Array_<Vec3> &, SimTK::Transform &)>(&SimTK::Geo::Point::calcPrincipalComponents));
  // types.method("calcPrincipalComponentsIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, SimTK::Transform &)>(&SimTK::Geo::Point::calcPrincipalComponentsIndirect));
  types.method("findAxisAlignedExtremePoints", static_cast<void (*)(const SimTK::Array_<Vec3>&, int[3], int[3], Vec3&, Vec3&)>(&SimTK::Geo::Point::findAxisAlignedExtremePoints));
  types.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox (*)(const SimTK::Array_<Vec3>&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcAxisAlignedBoundingBox));
  types.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcAxisAlignedBoundingBox));
  types.method("findOrientedExtremePoints", static_cast<void (*)(const SimTK::Array_<Vec3>&, const SimTK::Rotation&, int[3], int[3], Vec3&, Vec3&)>(&SimTK::Geo::Point::findOrientedExtremePoints));
  types.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox (*)(const SimTK::Array_<Vec3>&, SimTK::Array_<int>&, bool)>(&SimTK::Geo::Point::calcOrientedBoundingBox));
  types.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcOrientedBoundingBox));

  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&, const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const std::vector<Vec3>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&, bool, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&, const Vec3&, bool, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const SimTK::Array_<Vec3>&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcApproxBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcApproxBoundingSphere));
  types.method("calcApproxBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const std::vector<Vec3>&)>(&SimTK::Geo::Point::calcApproxBoundingSphere));

  /* End of SimTK::Geo::Point_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Triangle_
   */
  auto t10_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Triangle_<P>> wrapped){
    typedef SimTK::Geo::Triangle_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<3,P>* >(/*finalize=*/true);

    wrapped.method("setVertex", static_cast<WrappedType& (WrappedType::*)(int, const SimTK::Vec<3,P>&)>(&WrappedType::setVertex));
    wrapped.method("setVertices", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&)>(&WrappedType::setVertices));
    wrapped.method("setVertices", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>* )>(&WrappedType::setVertices));
    wrapped.method("getVertex", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)(int) const>(&WrappedType::getVertex));
    wrapped.method("updVertex", static_cast<SimTK::Vec<3,P>& (WrappedType::*)(int)>(&WrappedType::updVertex));
    wrapped.method("getEdge", static_cast<SimTK::Geo::LineSeg_<P> (WrappedType::*)(int) const>(&WrappedType::getEdge));
    wrapped.method("findPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<2,P>&) const>(&WrappedType::findPoint));
    wrapped.method("findCentroid", static_cast<SimTK::Vec<3,P> (WrappedType::*)() const>(&WrappedType::findCentroid));
    wrapped.method("calcUnitNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)() const>(&WrappedType::calcUnitNormal));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("calcArea", static_cast<P (WrappedType::*)() const>(&WrappedType::calcArea));
    wrapped.method("calcAreaSqr", static_cast<P (WrappedType::*)() const>(&WrappedType::calcAreaSqr));
    wrapped.method("findNearestPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&, SimTK::Vec<2,P>&) const>(&WrappedType::findNearestPoint));
    wrapped.method("intersectsRay", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&, const SimTK::UnitVec<P,1>&, P&, SimTK::Vec<2,P>&) const>(&WrappedType::intersectsRay));
    wrapped.method("overlapsTriangle", static_cast<bool (WrappedType::*)(const SimTK::Geo::Triangle_<P>&) const>(&WrappedType::overlapsTriangle));
    wrapped.method("intersectsTriangle", static_cast<bool (WrappedType::*)(const SimTK::Geo::Triangle_<P>&, SimTK::Geo::LineSeg_<P>&, bool&) const>(&WrappedType::intersectsTriangle));

  };
  t10.apply<SimTK::Geo::Triangle_<double>>(t10_decl_methods);

  /* End of SimTK::Geo::Triangle_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::CubicHermiteCurve_
   */
  auto t11_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::CubicHermiteCurve_<P>> wrapped){
    typedef SimTK::Geo::CubicHermiteCurve_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<4, SimTK::Vec<3,P>> &>(/*finalize=*/true);

    wrapped.method("getAlgebraicCoefficients", static_cast<const SimTK::Vec<4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getAlgebraicCoefficients));
    wrapped.method("calcGeometricCoefficients", static_cast<SimTK::Vec<4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcGeometricCoefficients));
    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalP));
    wrapped.method("evalPu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPu));
    wrapped.method("evalPuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuu));
    wrapped.method("evalPuuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuuu));
  };
  t11.apply<SimTK::Geo::CubicHermiteCurve_<double>>(t11_decl_methods);

  types.method("calcU", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcU));
  types.method("calcFh", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFh));
  types.method("calcFhu", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFhu));
  types.method("calcFhuu", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFhuu));
  types.method("calcFhuuu", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFhuuu));
  types.method("calcAFromH", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicHermiteCurve::calcAFromH));
  types.method("calcHFromA", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicHermiteCurve::calcHFromA));
  types.method("evalPUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPUsingA));
  types.method("evalPuUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuUsingA));
  types.method("evalPuuUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuUsingA));
  types.method("evalPuuuUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuuUsingA));
  types.method("evalPUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPUsingH));
  types.method("evalPuUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuUsingH));
  types.method("evalPuuUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuUsingH));
  types.method("evalPuuuUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuuUsingH));
  types.method("getMh", static_cast<SimTK::Mat44 (*)()>(SimTK::Geo::CubicHermiteCurve::getMh));
  types.method("multiplyByMh", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicHermiteCurve::multiplyByMh));
  types.method("getMhInv", static_cast<SimTK::Mat44 (*)()>(SimTK::Geo::CubicHermiteCurve::getMhInv));
  types.method("multiplyByMhInv", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicHermiteCurve::multiplyByMhInv));

  /* End of SimTK::Geo::CubicHermiteCurve_ class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::BicubicHermitePatch_
   */
  auto t12_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::BicubicHermitePatch_<P>> wrapped){
    typedef SimTK::Geo::BicubicHermitePatch_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Mat<4,4,SimTK::Vec<3,P>> &>(/*finalize=*/true);

    wrapped.method("getAlgebraicCoefficients", static_cast<const SimTK::Mat<4,4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getAlgebraicCoefficients));
    wrapped.method("calcHermiteCoefficients", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcHermiteCoefficients));
    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P, P) const>(&WrappedType::evalP));
    wrapped.method("evalP1", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP1));
    wrapped.method("evalP2", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP2));
    wrapped.method("evalP3", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP3));
  };
  t12.apply<SimTK::Geo::BicubicHermitePatch_<double>>(t12_decl_methods);

  types.method("calcAFromH", static_cast<SimTK::Mat<4,4, SimTK::Vec3> (*)(const SimTK::Mat<4,4, SimTK::Vec3>&)>(&SimTK::Geo::BicubicHermitePatch::calcAFromH));
  types.method("calcHFromA", static_cast<SimTK::Mat<4,4, SimTK::Vec3> (*)(const SimTK::Mat<4,4, SimTK::Vec3>&)>(&SimTK::Geo::BicubicHermitePatch::calcHFromA));
  types.method("evalPUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double)>(&SimTK::Geo::BicubicHermitePatch::evalPUsingA));
  types.method("evalP1UsingA", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicHermitePatch::evalP1UsingA));
  types.method("evalP2UsingA", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicHermitePatch::evalP2UsingA));
  types.method("evalP3UsingA", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicHermitePatch::evalP3UsingA));

  /* End of SimTK::Geo::BicubicHermitePatch_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::CubicBezierCurve_
   */
  auto t13_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::CubicBezierCurve_<P>> wrapped){
    typedef SimTK::Geo::CubicBezierCurve_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Vec<4, SimTK::Vec<3,P>> &>(/*finalize=*/true);

    wrapped.method("getControlPoints", static_cast<const SimTK::Vec<4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getControlPoints));
    wrapped.method("calcAlgebraicCoefficients", static_cast<SimTK::Vec<4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcAlgebraicCoefficients));
    wrapped.method("calcHermiteCoefficients", static_cast<SimTK::Vec<4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcHermiteCoefficients));
    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalP));
    wrapped.method("evalPu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPu));
    wrapped.method("evalPuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuu));
    wrapped.method("evalPuuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuuu));
    wrapped.method("calcDsdu", static_cast<P (WrappedType::*)(P) const>(&WrappedType::calcDsdu));
    wrapped.method("calcUnitTangent", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(P) const>(&WrappedType::calcUnitTangent));
    wrapped.method("calcCurvatureVector", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::calcCurvatureVector));
    wrapped.method("calcCurvatureSqr", static_cast<P (WrappedType::*)(P)>(&WrappedType::calcCurvatureSqr));
    wrapped.method("calcTorsion", static_cast<P (WrappedType::*)(P)>(&WrappedType::calcTorsion));
    wrapped.method("calcUnitNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(P) const>(&WrappedType::calcUnitNormal));
    wrapped.method("calcCurveFrame", static_cast<P (WrappedType::*)(P, SimTK::Transform_<P>&) const>(&WrappedType::calcCurveFrame));
    wrapped.method("split", static_cast<void (WrappedType::*)(P, WrappedType&, WrappedType&) const>(&WrappedType::split));
    wrapped.method("bisect", static_cast<void (WrappedType::*)(WrappedType&, WrappedType&) const>(&WrappedType::bisect));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox_<P> (WrappedType::*)() const>(&WrappedType::calcAxisAlignedBoundingBox));
    wrapped.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox_<P> (WrappedType::*)() const>(&WrappedType::calcOrientedBoundingBox));
  };
  t13.apply<SimTK::Geo::CubicBezierCurve_<double>>(t13_decl_methods);

  types.method("calcFb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcFb));
  types.method("calcDFb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcDFb));
  types.method("calcD2Fb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcD2Fb));
  types.method("calcD3Fb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcD3Fb));
  types.method("calcAFromB", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcAFromB));
  types.method("calcBFromA", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcBFromA));
  types.method("calcHFromB", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcHFromB));
  types.method("calcBFromH", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcBFromH));
  types.method("evalPUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPUsingB));
  types.method("evalPuUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPuUsingB));
  types.method("evalPuuUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPuuUsingB));
  types.method("evalPuuuUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPuuuUsingB));
  types.method("getMb", static_cast<SimTK::Mat44 (*)()>(SimTK::Geo::CubicBezierCurve::getMb));
  types.method("multiplyByMb", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMb));
  types.method("getMbInv", static_cast<SimTK::Mat44 (*)()>(&SimTK::Geo::CubicBezierCurve::getMbInv));
  types.method("multiplyByMbInv", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMbInv));
  types.method("getMhInvMb", static_cast<SimTK::Mat44 (*)()>(&SimTK::Geo::CubicBezierCurve::getMhInvMb));
  types.method("multiplyByMhInvMb", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMhInvMb));
  types.method("getMbInvMh", static_cast<SimTK::Mat44 (*)()>(&SimTK::Geo::CubicBezierCurve::getMbInvMh));
  types.method("multiplyByMbInvMh", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMbInvMh));

  /* End of SimTK::Geo::CubicBezierCurve_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::BicubicBezierPatch_
   */
  auto t14_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::BicubicBezierPatch_<P>> wrapped){
    typedef SimTK::Geo::BicubicBezierPatch_<P> WrappedType;
    wrapped.template constructor<>(/*finalize=*/true);
    wrapped.template constructor<const SimTK::Mat<4,4, SimTK::Vec<3,P>> &>(/*finalize=*/true);

    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P, P) const>(&WrappedType::evalP));
    wrapped.method("evalP1", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP1));
    wrapped.method("evalP2", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP2));
    wrapped.method("evalP3", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP3));

    wrapped.method("getControlPoints", static_cast<const SimTK::Mat<4,4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getControlPoints));
    wrapped.method("updControlPoints", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> & (WrappedType::*)()>(&WrappedType::updControlPoints));
    wrapped.method("calcAlgebraicCoefficients", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcAlgebraicCoefficients));
    wrapped.method("calcHermiteCoefficients", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcHermiteCoefficients));
    wrapped.method("getBoundaryCurveU0", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveU0));
    wrapped.method("getBoundaryCurveU1", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveU1));
    wrapped.method("getBoundaryCurveW0", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveW0));
    wrapped.method("getBoundaryCurveW1", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveW1));
    wrapped.method("calcIsoCurveU", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)(P) const>(&WrappedType::calcIsoCurveU));
    wrapped.method("calcIsoCurveW", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)(P) const>(&WrappedType::calcIsoCurveW));
    wrapped.method("splitU", static_cast<void (WrappedType::*)(P, WrappedType &, WrappedType &) const>(&WrappedType::splitU));
    wrapped.method("splitW", static_cast<void (WrappedType::*)(P, WrappedType &, WrappedType &) const>(&WrappedType::splitW));
    wrapped.method("split", static_cast<void (WrappedType::*)(P, P, WrappedType &, WrappedType &, WrappedType &, WrappedType &) const>(&WrappedType::split));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox_<P> (WrappedType::*)() const>(&WrappedType::calcAxisAlignedBoundingBox));
    wrapped.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox_<P> (WrappedType::*)() const>(&WrappedType::calcOrientedBoundingBox));
  };
  t14.apply<SimTK::Geo::BicubicBezierPatch_<double>>(t14_decl_methods);

  types.method("evalPUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Mat<4,4, SimTK::Vec3> &, double, double)>(&SimTK::Geo::BicubicBezierPatch::evalPUsingB));
  types.method("evalP1UsingB", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3> &, double, double, SimTK::Vec3 &, SimTK::Vec3 &)>(&SimTK::Geo::BicubicBezierPatch::evalP1UsingB));
  types.method("evalP2UsingB", static_cast<void (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicBezierPatch::evalP2UsingB));
  types.method("evalP3UsingB", static_cast<void (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicBezierPatch::evalP3UsingB));
  types.method("calcIsoCurveU", static_cast<SimTK::Geo::CubicBezierCurve (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double)>(&SimTK::Geo::BicubicBezierPatch::calcIsoCurveU));
  types.method("calcIsoCurveW", static_cast<SimTK::Geo::CubicBezierCurve (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double)>(&SimTK::Geo::BicubicBezierPatch::calcIsoCurveW));
  types.method("calcAFromB", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcAFromB));
  types.method("calcBFromA", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcBFromA));
  types.method("calcHFromB", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcHFromB));
  types.method("calcBFromH", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcBFromH));

  /* End of SimTK::Geo::BicubicBezierPatch_ class method wrappers
   **********************************************************************/

  // static bool 	isCusp (const Vec< 3, RealP, S > &Pu)
  types.method("isCusp", static_cast<bool (*)(const SimTK::Vec<3,double> &)>(&SimTK::Geo::isCusp));

  // static bool 	isInflectionPoint (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("isInflectionPoint", static_cast<bool (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::isInflectionPoint));

  // static UnitVec< RealP, 1 > 	calcUnitTangent (const Vec< 3, RealP, S > &Pu)
  types.method("calcUnitTangent", static_cast<SimTK::UnitVec<double,1> (*)(const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcUnitTangent));

  // static Vec< 3, RealP > 	calcCurvatureVector (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("calcCurvatureVector", static_cast<SimTK::Vec<3,double> (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcCurvatureVector));

  // static UnitVec< RealP, 1 > 	calcUnitNormal (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("calcUnitNormal", static_cast<SimTK::UnitVec<double,1> (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcUnitNormal));

  // static RealP 	calcCurveFrame (const Vec< 3, RealP, S > &P, const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu, Transform_< RealP > &X_FP)
  types.method("calcCurveFrame", static_cast<double (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &, SimTK::Transform_<double> &)>(&SimTK::Geo::calcCurveFrame));

  // static RealP 	calcCurvatureSqr (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("calcCurvatureSqr", static_cast<double (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcCurvatureSqr));

  // static RealP 	calcTorsion (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu, const Vec< 3, RealP, S > &Puuu)
  types.method("calcTorsion", static_cast<double (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcTorsion));

  // static void 	findClosestPointsOfTwoLines (const Vec< 3, RealP > &p0, const UnitVec< RealP, 1 > &d0, const Vec< 3, RealP > &p1, const UnitVec< RealP, 1 > &d1, Vec< 3, RealP > &x0, Vec< 3, RealP > &x1, bool &linesAreParallel)
  types.method("findClosestPointsOfTwoLines", static_cast<void (*)(const SimTK::Vec<3,double> &, const SimTK::UnitVec<double,1> &, const SimTK::Vec<3,double> &, const SimTK::UnitVec<double,1> &, SimTK::Vec<3,double> &, SimTK::Vec<3,double> &, bool &)>(&SimTK::Geo::findClosestPointsOfTwoLines));

  DEBUG_MSG("End of wrapper definitions");

}
}
