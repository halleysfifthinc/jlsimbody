// this file was auto-generated by wrapit v0.1.0-61-g71d8603-dirty
#include <type_traits>
#include "jlcxx/jlcxx.hpp"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

#include "jlsimmath/Geo.h"

#ifdef VERBOSE_IMPORT
#  define DEBUG_MSG(a) std::cerr << a << "\n"
#else
#  define DEBUG_MSG(a)
#endif
#define __HERE__  __FILE__ ":" QUOTE2(__LINE__)
#define QUOTE(arg) #arg
#define QUOTE2(arg) QUOTE(arg)

namespace jlsimbody{

void define_simmath_Geo(jlcxx::Module& types){

  // DEBUG_MSG("Adding wrapper for type SimTK::Geo (" __HERE__ ")");
  // // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:53:28
  // auto t0 = types.add_type<SimTK::Geo>("SimTK!Geo");
  // t0.template constructor<>();

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:55:26
  auto t1 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Point_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:56:26
  auto t2 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Sphere_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:57:26
  auto t3 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!LineSeg_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:61:26
  auto t7 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Box_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:62:26
  auto t8 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!AlignedBox_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:63:26
  auto t9 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!OrientedBox_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:64:26
  auto t10 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!Triangle_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:65:26
  auto t11 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!CubicHermiteCurve_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:66:26
  auto t12 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!BicubicHermitePatch_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:67:26
  auto t13 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!CubicBezierCurve_");

  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geo.h:68:26
  auto t14 = types.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("SimTK!Geo!BicubicBezierPatch_");


  DEBUG_MSG("Adding wrapper for type SimTK::Geodesic (" __HERE__ ")");
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:51:28
  auto t15 = types.add_type<SimTK::Geodesic>("SimTK!Geodesic");
  t15.template constructor<>();

  DEBUG_MSG("Adding wrapper for type SimTK::GeodesicOptions (" __HERE__ ")");
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:311:7
  auto t16 = types.add_type<SimTK::GeodesicOptions>("SimTK!GeodesicOptions");
  t16.template constructor<>();

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Sphere_
   */
  auto t2_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Sphere_<P>> wrapped){
    typedef SimTK::Geo::Sphere_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<3,P>&, P>();

    wrapped.method("setRadius", static_cast<WrappedType& (WrappedType::*)(P)>(&WrappedType::setRadius));
    wrapped.method("getRadius", static_cast<P (WrappedType::*)() const>(&WrappedType::getRadius));
    wrapped.method("updRadius", static_cast<P& (WrappedType::*)()>(&WrappedType::updRadius));

    wrapped.method("setCenter", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setCenter));
    wrapped.method("getCenter", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getCenter));
    wrapped.method("updCenter", static_cast<SimTK::Vec<3,P>& (WrappedType::*)()>(&WrappedType::updCenter));

    wrapped.method("scaleBy", static_cast<WrappedType& (WrappedType::*)(P)>(&WrappedType::scaleBy));
    wrapped.method("stretchBoundary", static_cast<WrappedType& (WrappedType::*)()>(&WrappedType::stretchBoundary));
    wrapped.method("findVolume", static_cast<P (WrappedType::*)() const>(&WrappedType::findVolume));
    wrapped.method("findArea", static_cast<P (WrappedType::*)() const>(&WrappedType::findArea));

    wrapped.method("isPointOutside", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::isPointOutside));
    wrapped.method("isPointOutside", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&, P) const>(&WrappedType::isPointOutside));
  };
  t2.apply<SimTK::Geo::Sphere_<double>>(t2_decl_methods);

  /* End of SimTK::Geo::Sphere_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::LineSeg_
   */
  auto t3_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::LineSeg_<P>> wrapped){
    typedef SimTK::Geo::LineSeg_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&>();

    wrapped.method("setEndpoints", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&)>(&WrappedType::setEndpoints));
    wrapped.method("setEndpoint", static_cast<WrappedType& (WrappedType::*)(int, const SimTK::Vec<3,P>&)>(&WrappedType::setEndpoint));
    wrapped.method("getEndpoint", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)(int) const>(&WrappedType::getEndpoint));
    wrapped.method("updEndpoint", static_cast<SimTK::Vec<3,P>& (WrappedType::*)(int)>(&WrappedType::updEndpoint));
    wrapped.method("calcLength", static_cast<P (WrappedType::*)() const>(&WrappedType::calcLength));
    wrapped.method("calcLengthSqr", static_cast<P (WrappedType::*)() const>(&WrappedType::calcLengthSqr));
    wrapped.method("findPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::findPoint));
    wrapped.method("findMidpoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)() const>(&WrappedType::findMidpoint));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("findDistanceToPoint", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceToPoint));
    wrapped.method("findDistanceToPointSqr", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceToPointSqr));

    wrapped.module().set_override_module(jl_base_module);
    
    wrapped.method("getindex", [](const WrappedType& self, int i) {
      return self[i-1];
    });
    
    wrapped.module().unset_override_module();
  };
  t3.apply<SimTK::Geo::LineSeg_<double>>(t3_decl_methods);

  /* End of SimTK::Geo::LineSeg_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Box_
   */
  auto t7_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Box_<P>> wrapped){
    typedef SimTK::Geo::Box_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<3,P>&>();

    wrapped.method("setHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setHalfLengths));
    wrapped.method("addToHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::addToHalfLengths));
    wrapped.method("getOrderedHalfLength", static_cast<P (WrappedType::*)(int) const>(&WrappedType::getOrderedHalfLength));
    wrapped.method("getOrderedAxis", static_cast<SimTK::CoordinateAxis (WrappedType::*)(int) const>(&WrappedType::getOrderedAxis));

    wrapped.method("findVolume", static_cast<P (WrappedType::*)() const>(&WrappedType::findVolume));
    wrapped.method("findArea", static_cast<P (WrappedType::*)() const>(&WrappedType::findArea));
    wrapped.method("containsPoint", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::containsPoint));
    wrapped.method("findClosestPointOfSolidBox", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&, bool&) const>(&WrappedType::findClosestPointOfSolidBox));
    wrapped.method("findClosestPointOnSurface", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&, bool&) const>(&WrappedType::findClosestPointOnSurface));
    wrapped.method("findDistanceSqrToPoint", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceSqrToPoint));
    wrapped.method("findSupportPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findSupportPoint));
    wrapped.method("findDistanceSqrToSphere", static_cast<P (WrappedType::*)(const SimTK::Geo::Sphere_<P>&) const>(&WrappedType::findDistanceSqrToSphere));
    // wrapped.method("findDistanceSqrToAlignedBox", static_cast<P (WrappedType::*)(const SimTK::Geo::AlignedBox_<P>&) const>(&WrappedType::findDistanceSqrToAlignedBox));
    
    wrapped.method("intersectsSphere", static_cast<bool (WrappedType::*)(const SimTK::Geo::Sphere_<P>&) const>(&WrappedType::intersectsSphere));
    // wrapped.method("intersectsAlignedBox", static_cast<bool (WrappedType::*)(const SimTK::Geo::AlignedBox_<P>&) const>(&WrappedType::intersectsAlignedBox));
    // wrapped.method("intersectsOrientedBox", static_cast<bool (WrappedType::*)(const SimTK::Geo::OrientedBox_<P>&) const>(&WrappedType::intersectsOrientedBox));
    // wrapped.method("mayIntersectOrientedBox", static_cast<bool (WrappedType::*)(const SimTK::Geo::OrientedBox_<P>&) const>(&WrappedType::mayIntersectOrientedBox));

    wrapped.method("getVertexPos", static_cast<SimTK::Vec<3,P> (WrappedType::*)(int) const>(&WrappedType::getVertexPos));
    wrapped.method("findSupportVertex", static_cast<int (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findSupportVertex));
    wrapped.method("getVertexNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getVertexNormal));
    wrapped.method("getEdgeCenter", static_cast<SimTK::Vec<3,P> (WrappedType::*)(int) const>(&WrappedType::getEdgeCenter));
    wrapped.method("getEdgeNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getEdgeNormal));
    wrapped.method("getEdgeCoordinateDirection", static_cast<SimTK::CoordinateDirection (WrappedType::*)(int) const>(&WrappedType::getEdgeCoordinateDirection));
    wrapped.method("getEdgeDirection", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getEdgeDirection));

    wrapped.method("getFaceCoordinateDirection", static_cast<SimTK::CoordinateDirection (WrappedType::*)(int) const>(&WrappedType::getFaceCoordinateDirection));
    wrapped.method("getFaceCenter", static_cast<SimTK::Vec<3,P> (WrappedType::*)(int) const>(&WrappedType::getFaceCenter));
    wrapped.method("getFaceNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(int) const>(&WrappedType::getFaceNormal));
    wrapped.method("getFaceVertices", static_cast<void (WrappedType::*)(int, int[4]) const>(&WrappedType::getFaceVertices));
    wrapped.method("getVertexFaces", static_cast<void (WrappedType::*)(int, int[3], int[3]) const>(&WrappedType::getVertexFaces));
    wrapped.method("getEdgeVertices", static_cast<void (WrappedType::*)(int, int[2]) const>(&WrappedType::getEdgeVertices));
    wrapped.method("getVertexEdges", static_cast<void (WrappedType::*)(int, int[3], int[3]) const>(&WrappedType::getVertexEdges));
    wrapped.method("getFaceEdges", static_cast<void (WrappedType::*)(int, int[4]) const>(&WrappedType::getFaceEdges));
    wrapped.method("getEdgeFaces", static_cast<void (WrappedType::*)(int, int[2], int[2]) const>(&WrappedType::getEdgeFaces));
    wrapped.method("getNumVertices", []() { return 8; });
    wrapped.method("getNumEdges", []() { return 12; });
    wrapped.method("getNumFaces", []() { return 6; });

  };
  t7.apply<SimTK::Geo::Box_<double>>(t7_decl_methods);

  /* End of SimTK::Geo::Box_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::AlignedBox_
   */
  auto t8_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::AlignedBox_<P>> wrapped){
    typedef SimTK::Geo::AlignedBox_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Geo::Box_<P>&>();
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&>();

    wrapped.method("setCenter", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setCenter));
    wrapped.method("setHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setHalfLengths));
    wrapped.method("getCenter", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getCenter));
    wrapped.method("updCenter", static_cast<SimTK::Vec<3,P>& (WrappedType::*)()>(&WrappedType::updCenter));
    wrapped.method("getHalfLengths", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getHalfLengths));
    wrapped.method("getBox", static_cast<const SimTK::Geo::Box_<P>& (WrappedType::*)() const>(&WrappedType::getBox));
    wrapped.method("updBox", static_cast<SimTK::Geo::Box_<P>& (WrappedType::*)()>(&WrappedType::updBox));
    wrapped.method("containsPoint", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::containsPoint));
    wrapped.method("stretchBoundary", static_cast<WrappedType& (WrappedType::*)()>(&WrappedType::stretchBoundary));
  };
  t8.apply<SimTK::Geo::AlignedBox_<double>>(t8_decl_methods);

  // types.method("intersectsAlignedBox", static_cast<bool (*)(const SimTK::Geo::Box&, const SimTK::Geo::AlignedBox&)>(&SimTK::Geo::Box::intersectsAlignedBox));
  types.method("intersectsAlignedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::AlignedBox& abox) -> bool {
    return box.intersectsAlignedBox(abox);
  });
  // wrapped.method("findDistanceSqrToAlignedBox", static_cast<P (WrappedType::*)(const SimTK::Geo::AlignedBox_<P>&) const>(&WrappedType::findDistanceSqrToAlignedBox));
  types.method("findDistanceSqrToAlignedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::AlignedBox& abox) -> double {
    return box.findDistanceSqrToAlignedBox(abox);
  });

  /* End of SimTK::Geo::AlignedBox_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::OrientedBox_
   */
  auto t9_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::OrientedBox_<P>> wrapped){
    typedef SimTK::Geo::OrientedBox_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Transform_<P>&, const SimTK::Geo::Box_<P>&>();
    wrapped.template constructor<const SimTK::Transform_<P>&, const SimTK::Vec<3,P>&>();

    wrapped.method("setTransform", static_cast<WrappedType& (WrappedType::*)(const SimTK::Transform_<P>&)>(&WrappedType::setTransform));
    wrapped.method("setHalfLengths", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setHalfLengths));
    wrapped.method("getCenter", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getCenter));
    wrapped.method("updCenter", static_cast<SimTK::Vec<3,P>& (WrappedType::*)()>(&WrappedType::updCenter));
    wrapped.method("getOrientation", static_cast<const SimTK::Rotation_<P>& (WrappedType::*)() const>(&WrappedType::getOrientation));
    wrapped.method("updOrientation", static_cast<SimTK::Rotation_<P>& (WrappedType::*)()>(&WrappedType::updOrientation));
    wrapped.method("getTransform", static_cast<const SimTK::Transform_<P>& (WrappedType::*)() const>(&WrappedType::getTransform));
    wrapped.method("updTransform", static_cast<SimTK::Transform_<P>& (WrappedType::*)()>(&WrappedType::updTransform));
    wrapped.method("getHalfLengths", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getHalfLengths));
    wrapped.method("getBox", static_cast<const SimTK::Geo::Box_<P>& (WrappedType::*)() const>(&WrappedType::getBox));
    wrapped.method("updBox", static_cast<SimTK::Geo::Box_<P>& (WrappedType::*)()>(&WrappedType::updBox));
    wrapped.method("containsPoint", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::containsPoint));
    wrapped.method("stretchBoundary", static_cast<WrappedType& (WrappedType::*)()>(&WrappedType::stretchBoundary));
  };
  t9.apply<SimTK::Geo::OrientedBox_<double>>(t9_decl_methods);

  // wrapped.method("intersectsOrientedBox", static_cast<bool (SimTK::Geo::Box_<P>::*)(const WrappedType&) const>(&SimTK::Geo::Box_<P>::intersectsOrientedBox));
  // wrapped.method("mayIntersectOrientedBox", static_cast<bool (SimTK::Geo::Box_<P>::*)(const WrappedType&) const>(&SimTK::Geo::Box_<P>::mayIntersectOrientedBox));
  types.method("intersectsOrientedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::OrientedBox& obox) -> bool {
    return box.intersectsOrientedBox(obox);
  });
  types.method("mayIntersectOrientedBox", [] (const SimTK::Geo::Box& box, const SimTK::Geo::OrientedBox& obox) -> bool {
    return box.mayIntersectOrientedBox(obox);
  });

  /* End of SimTK::Geo::OrientedBox_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Point_
   */
  auto t1_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Point_<P>> wrapped){
    typedef SimTK::Geo::Point_<P> WrappedType;
    wrapped.template constructor<>();

    wrapped.method("setLocation", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&)>(&WrappedType::setLocation));
    wrapped.method("getLocation", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)() const>(&WrappedType::getLocation));
    wrapped.method("calcDistance", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::calcDistance));
    wrapped.method("findDistanceSqr", static_cast<P (WrappedType::*)(const SimTK::Vec<3,P>&) const>(&WrappedType::findDistanceSqr));
  };
  t1.apply<SimTK::Geo::Point_<double>>(t1_decl_methods);

  typedef SimTK::Vec3 Vec3;
  types.method("calcDistance", static_cast<double (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::calcDistance));
  types.method("findDistanceSqr", static_cast<double (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::findDistanceSqr));
  types.method("findMidpoint", static_cast<Vec3 (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::findMidpoint));
  types.method("pointsAreNumericallyCoincident", static_cast<bool (*)(const Vec3 &, const Vec3 &)>(&SimTK::Geo::Point::pointsAreNumericallyCoincident));
  types.method("pointsAreNumericallyCoincident", static_cast<bool (*)(const Vec3 &, const Vec3 &, double)>(&SimTK::Geo::Point::pointsAreNumericallyCoincident));
  types.method("findSupportPoint", static_cast<void (*)(const SimTK::Array_<Vec3> &, const SimTK::UnitVec<double,1> &, int &, double &)>(&SimTK::Geo::Point::findSupportPoint));
  // types.method("findSupportPointIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, const SimTK::UnitVec<double,1> &, int &, double &)>(&SimTK::Geo::Point::findSupportPointIndirect));
  types.method("findExtremePoints", static_cast<void (*)(const SimTK::Array_<Vec3> &, const SimTK::UnitVec<double,1> &, int &, int &, double &, double &)>(&SimTK::Geo::Point::findExtremePoints));
  // types.method("findExtremePointsIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, const SimTK::UnitVec<double,1> &, int &, int &, double &, double &)>(&SimTK::Geo::Point::findExtremePointsIndirect));
  types.method("calcCentroid", static_cast<Vec3 (*)(const SimTK::Array_<Vec3> &)>(&SimTK::Geo::Point::calcCentroid));
  // types.method("calcCentroidIndirect", static_cast<Vec3 (*)(const SimTK::Array_<const Vec3 *> &)>(&SimTK::Geo::Point::calcCentroidIndirect));
  // types.method("calcCovariance", static_cast<void (*)(const SimTK::Array_<Vec3> &, Vec3 &, SimTK::SymMat<3,3,double> &)>(&SimTK::Geo::Point::calcCovariance));
  // types.method("calcCovarianceIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, Vec3 &, SimTK::SymMat<3,3,double> &)>(&SimTK::Geo::Point::calcCovarianceIndirect));
  types.method("calcPrincipalComponents", static_cast<void (*)(const SimTK::Array_<Vec3> &, SimTK::Transform &)>(&SimTK::Geo::Point::calcPrincipalComponents));
  // types.method("calcPrincipalComponentsIndirect", static_cast<void (*)(const SimTK::Array_<const Vec3 *> &, SimTK::Transform &)>(&SimTK::Geo::Point::calcPrincipalComponentsIndirect));
  types.method("findAxisAlignedExtremePoints", static_cast<void (*)(const SimTK::Array_<Vec3>&, int[3], int[3], Vec3&, Vec3&)>(&SimTK::Geo::Point::findAxisAlignedExtremePoints));
  types.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox (*)(const SimTK::Array_<Vec3>&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcAxisAlignedBoundingBox));
  types.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcAxisAlignedBoundingBox));
  types.method("findOrientedExtremePoints", static_cast<void (*)(const SimTK::Array_<Vec3>&, const SimTK::Rotation&, int[3], int[3], Vec3&, Vec3&)>(&SimTK::Geo::Point::findOrientedExtremePoints));
  types.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox (*)(const SimTK::Array_<Vec3>&, SimTK::Array_<int>&, bool)>(&SimTK::Geo::Point::calcOrientedBoundingBox));
  types.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcOrientedBoundingBox));

  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&, const Vec3&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const std::vector<Vec3>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&, bool, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const Vec3&, const Vec3&, const Vec3&, const Vec3&, bool, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const SimTK::Array_<Vec3>&, SimTK::Array_<int>&)>(&SimTK::Geo::Point::calcBoundingSphere));
  types.method("calcApproxBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const SimTK::Array_<Vec3>&)>(&SimTK::Geo::Point::calcApproxBoundingSphere));
  types.method("calcApproxBoundingSphere", static_cast<SimTK::Geo::Sphere (*)(const std::vector<Vec3>&)>(&SimTK::Geo::Point::calcApproxBoundingSphere));

  /* End of SimTK::Geo::Point_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::Triangle_
   */
  auto t10_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::Triangle_<P>> wrapped){
    typedef SimTK::Geo::Triangle_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&>();
    wrapped.template constructor<const SimTK::Vec<3,P>* >();

    wrapped.method("setVertex", static_cast<WrappedType& (WrappedType::*)(int, const SimTK::Vec<3,P>&)>(&WrappedType::setVertex));
    wrapped.method("setVertices", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&, const SimTK::Vec<3,P>&)>(&WrappedType::setVertices));
    wrapped.method("setVertices", static_cast<WrappedType& (WrappedType::*)(const SimTK::Vec<3,P>* )>(&WrappedType::setVertices));
    wrapped.method("getVertex", static_cast<const SimTK::Vec<3,P>& (WrappedType::*)(int) const>(&WrappedType::getVertex));
    wrapped.method("updVertex", static_cast<SimTK::Vec<3,P>& (WrappedType::*)(int)>(&WrappedType::updVertex));
    wrapped.method("getEdge", static_cast<SimTK::Geo::LineSeg_<P> (WrappedType::*)(int) const>(&WrappedType::getEdge));
    wrapped.method("findPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<2,P>&) const>(&WrappedType::findPoint));
    wrapped.method("findCentroid", static_cast<SimTK::Vec<3,P> (WrappedType::*)() const>(&WrappedType::findCentroid));
    wrapped.method("calcUnitNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)() const>(&WrappedType::calcUnitNormal));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("calcArea", static_cast<P (WrappedType::*)() const>(&WrappedType::calcArea));
    wrapped.method("calcAreaSqr", static_cast<P (WrappedType::*)() const>(&WrappedType::calcAreaSqr));
    wrapped.method("findNearestPoint", static_cast<SimTK::Vec<3,P> (WrappedType::*)(const SimTK::Vec<3,P>&, SimTK::Vec<2,P>&) const>(&WrappedType::findNearestPoint));
    wrapped.method("intersectsRay", static_cast<bool (WrappedType::*)(const SimTK::Vec<3,P>&, const SimTK::UnitVec<P,1>&, P&, SimTK::Vec<2,P>&) const>(&WrappedType::intersectsRay));
    wrapped.method("overlapsTriangle", static_cast<bool (WrappedType::*)(const SimTK::Geo::Triangle_<P>&) const>(&WrappedType::overlapsTriangle));
    wrapped.method("intersectsTriangle", static_cast<bool (WrappedType::*)(const SimTK::Geo::Triangle_<P>&, SimTK::Geo::LineSeg_<P>&, bool&) const>(&WrappedType::intersectsTriangle));

  };
  t10.apply<SimTK::Geo::Triangle_<double>>(t10_decl_methods);

  /* End of SimTK::Geo::Triangle_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::CubicHermiteCurve_
   */
  auto t11_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::CubicHermiteCurve_<P>> wrapped){
    typedef SimTK::Geo::CubicHermiteCurve_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<4, SimTK::Vec<3,P>> &>();

    wrapped.method("getAlgebraicCoefficients", static_cast<const SimTK::Vec<4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getAlgebraicCoefficients));
    wrapped.method("calcGeometricCoefficients", static_cast<SimTK::Vec<4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcGeometricCoefficients));
    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalP));
    wrapped.method("evalPu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPu));
    wrapped.method("evalPuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuu));
    wrapped.method("evalPuuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuuu));
  };
  t11.apply<SimTK::Geo::CubicHermiteCurve_<double>>(t11_decl_methods);

  types.method("calcU", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcU));
  types.method("calcFh", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFh));
  types.method("calcFhu", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFhu));
  types.method("calcFhuu", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFhuu));
  types.method("calcFhuuu", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicHermiteCurve::calcFhuuu));
  types.method("calcAFromH", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicHermiteCurve::calcAFromH));
  types.method("calcHFromA", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicHermiteCurve::calcHFromA));
  types.method("evalPUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPUsingA));
  types.method("evalPuUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuUsingA));
  types.method("evalPuuUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuUsingA));
  types.method("evalPuuuUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuuUsingA));
  types.method("evalPUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPUsingH));
  types.method("evalPuUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuUsingH));
  types.method("evalPuuUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuUsingH));
  types.method("evalPuuuUsingH", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicHermiteCurve::evalPuuuUsingH));
  types.method("getMh", static_cast<SimTK::Mat44 (*)()>(SimTK::Geo::CubicHermiteCurve::getMh));
  types.method("multiplyByMh", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicHermiteCurve::multiplyByMh));
  types.method("getMhInv", static_cast<SimTK::Mat44 (*)()>(SimTK::Geo::CubicHermiteCurve::getMhInv));
  types.method("multiplyByMhInv", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicHermiteCurve::multiplyByMhInv));

  /* End of SimTK::Geo::CubicHermiteCurve_ class method wrappers
   **********************************************************************/


  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::BicubicHermitePatch_
   */
  auto t12_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::BicubicHermitePatch_<P>> wrapped){
    typedef SimTK::Geo::BicubicHermitePatch_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Mat<4,4,SimTK::Vec<3,P>> &>();

    wrapped.method("getAlgebraicCoefficients", static_cast<const SimTK::Mat<4,4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getAlgebraicCoefficients));
    wrapped.method("calcHermiteCoefficients", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcHermiteCoefficients));
    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P, P) const>(&WrappedType::evalP));
    wrapped.method("evalP1", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP1));
    wrapped.method("evalP2", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP2));
    wrapped.method("evalP3", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP3));
  };
  t12.apply<SimTK::Geo::BicubicHermitePatch_<double>>(t12_decl_methods);

  types.method("calcAFromH", static_cast<SimTK::Mat<4,4, SimTK::Vec3> (*)(const SimTK::Mat<4,4, SimTK::Vec3>&)>(&SimTK::Geo::BicubicHermitePatch::calcAFromH));
  types.method("calcHFromA", static_cast<SimTK::Mat<4,4, SimTK::Vec3> (*)(const SimTK::Mat<4,4, SimTK::Vec3>&)>(&SimTK::Geo::BicubicHermitePatch::calcHFromA));
  types.method("evalPUsingA", static_cast<SimTK::Vec3 (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double)>(&SimTK::Geo::BicubicHermitePatch::evalPUsingA));
  types.method("evalP1UsingA", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicHermitePatch::evalP1UsingA));
  types.method("evalP2UsingA", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicHermitePatch::evalP2UsingA));
  types.method("evalP3UsingA", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicHermitePatch::evalP3UsingA));

  /* End of SimTK::Geo::BicubicHermitePatch_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::CubicBezierCurve_
   */
  auto t13_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::CubicBezierCurve_<P>> wrapped){
    typedef SimTK::Geo::CubicBezierCurve_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Vec<4, SimTK::Vec<3,P>> &>();

    wrapped.method("getControlPoints", static_cast<const SimTK::Vec<4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getControlPoints));
    wrapped.method("calcAlgebraicCoefficients", static_cast<SimTK::Vec<4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcAlgebraicCoefficients));
    wrapped.method("calcHermiteCoefficients", static_cast<SimTK::Vec<4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcHermiteCoefficients));
    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalP));
    wrapped.method("evalPu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPu));
    wrapped.method("evalPuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuu));
    wrapped.method("evalPuuu", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::evalPuuu));
    wrapped.method("calcDsdu", static_cast<P (WrappedType::*)(P) const>(&WrappedType::calcDsdu));
    wrapped.method("calcUnitTangent", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(P) const>(&WrappedType::calcUnitTangent));
    wrapped.method("calcCurvatureVector", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P) const>(&WrappedType::calcCurvatureVector));
    wrapped.method("calcCurvatureSqr", static_cast<P (WrappedType::*)(P)>(&WrappedType::calcCurvatureSqr));
    wrapped.method("calcTorsion", static_cast<P (WrappedType::*)(P)>(&WrappedType::calcTorsion));
    wrapped.method("calcUnitNormal", static_cast<SimTK::UnitVec<P,1> (WrappedType::*)(P) const>(&WrappedType::calcUnitNormal));
    wrapped.method("calcCurveFrame", static_cast<P (WrappedType::*)(P, SimTK::Transform_<P>&) const>(&WrappedType::calcCurveFrame));
    wrapped.method("split", static_cast<void (WrappedType::*)(P, WrappedType&, WrappedType&) const>(&WrappedType::split));
    wrapped.method("bisect", static_cast<void (WrappedType::*)(WrappedType&, WrappedType&) const>(&WrappedType::bisect));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox_<P> (WrappedType::*)() const>(&WrappedType::calcAxisAlignedBoundingBox));
    wrapped.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox_<P> (WrappedType::*)() const>(&WrappedType::calcOrientedBoundingBox));
  };
  t13.apply<SimTK::Geo::CubicBezierCurve_<double>>(t13_decl_methods);

  types.method("calcFb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcFb));
  types.method("calcDFb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcDFb));
  types.method("calcD2Fb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcD2Fb));
  types.method("calcD3Fb", reinterpret_cast<SimTK::Vec4 (*)(double)>(&SimTK::Geo::CubicBezierCurve::calcD3Fb));
  types.method("calcAFromB", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcAFromB));
  types.method("calcBFromA", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcBFromA));
  types.method("calcHFromB", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcHFromB));
  types.method("calcBFromH", static_cast<SimTK::Vec<4,SimTK::Vec3> (*)(const SimTK::Vec<4,SimTK::Vec3>&)>(&SimTK::Geo::CubicBezierCurve::calcBFromH));
  types.method("evalPUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPUsingB));
  types.method("evalPuUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPuUsingB));
  types.method("evalPuuUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPuuUsingB));
  types.method("evalPuuuUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Vec<4,SimTK::Vec3>&, double)>(&SimTK::Geo::CubicBezierCurve::evalPuuuUsingB));
  types.method("getMb", static_cast<SimTK::Mat44 (*)()>(SimTK::Geo::CubicBezierCurve::getMb));
  types.method("multiplyByMb", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMb));
  types.method("getMbInv", static_cast<SimTK::Mat44 (*)()>(&SimTK::Geo::CubicBezierCurve::getMbInv));
  types.method("multiplyByMbInv", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMbInv));
  types.method("getMhInvMb", static_cast<SimTK::Mat44 (*)()>(&SimTK::Geo::CubicBezierCurve::getMhInvMb));
  types.method("multiplyByMhInvMb", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMhInvMb));
  types.method("getMbInvMh", static_cast<SimTK::Mat44 (*)()>(&SimTK::Geo::CubicBezierCurve::getMbInvMh));
  types.method("multiplyByMbInvMh", static_cast<SimTK::Vec4 (*)(const SimTK::Vec4&)>(&SimTK::Geo::CubicBezierCurve::multiplyByMbInvMh));

  /* End of SimTK::Geo::CubicBezierCurve_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geo::BicubicBezierPatch_
   */
  auto t14_decl_methods = []<typename P> (jlcxx::TypeWrapper<SimTK::Geo::BicubicBezierPatch_<P>> wrapped){
    typedef SimTK::Geo::BicubicBezierPatch_<P> WrappedType;
    wrapped.template constructor<>();
    wrapped.template constructor<const SimTK::Mat<4,4, SimTK::Vec<3,P>> &>();

    wrapped.method("evalP", static_cast<SimTK::Vec<3,P> (WrappedType::*)(P, P) const>(&WrappedType::evalP));
    wrapped.method("evalP1", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP1));
    wrapped.method("evalP2", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP2));
    wrapped.method("evalP3", static_cast<void (WrappedType::*)(P, P, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&, SimTK::Vec<3,P>&) const>(&WrappedType::evalP3));

    wrapped.method("getControlPoints", static_cast<const SimTK::Mat<4,4, SimTK::Vec<3,P>> & (WrappedType::*)() const>(&WrappedType::getControlPoints));
    wrapped.method("updControlPoints", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> & (WrappedType::*)()>(&WrappedType::updControlPoints));
    wrapped.method("calcAlgebraicCoefficients", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcAlgebraicCoefficients));
    wrapped.method("calcHermiteCoefficients", static_cast<SimTK::Mat<4,4, SimTK::Vec<3,P>> (WrappedType::*)() const>(&WrappedType::calcHermiteCoefficients));
    wrapped.method("getBoundaryCurveU0", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveU0));
    wrapped.method("getBoundaryCurveU1", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveU1));
    wrapped.method("getBoundaryCurveW0", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveW0));
    wrapped.method("getBoundaryCurveW1", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)() const>(&WrappedType::getBoundaryCurveW1));
    wrapped.method("calcIsoCurveU", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)(P) const>(&WrappedType::calcIsoCurveU));
    wrapped.method("calcIsoCurveW", static_cast<SimTK::Geo::CubicBezierCurve_<P> (WrappedType::*)(P) const>(&WrappedType::calcIsoCurveW));
    wrapped.method("splitU", static_cast<void (WrappedType::*)(P, WrappedType &, WrappedType &) const>(&WrappedType::splitU));
    wrapped.method("splitW", static_cast<void (WrappedType::*)(P, WrappedType &, WrappedType &) const>(&WrappedType::splitW));
    wrapped.method("split", static_cast<void (WrappedType::*)(P, P, WrappedType &, WrappedType &, WrappedType &, WrappedType &) const>(&WrappedType::split));
    wrapped.method("calcBoundingSphere", static_cast<SimTK::Geo::Sphere_<P> (WrappedType::*)() const>(&WrappedType::calcBoundingSphere));
    wrapped.method("calcAxisAlignedBoundingBox", static_cast<SimTK::Geo::AlignedBox_<P> (WrappedType::*)() const>(&WrappedType::calcAxisAlignedBoundingBox));
    wrapped.method("calcOrientedBoundingBox", static_cast<SimTK::Geo::OrientedBox_<P> (WrappedType::*)() const>(&WrappedType::calcOrientedBoundingBox));
  };
  t14.apply<SimTK::Geo::BicubicBezierPatch_<double>>(t14_decl_methods);

  types.method("evalPUsingB", static_cast<SimTK::Vec3 (*)(const SimTK::Mat<4,4, SimTK::Vec3> &, double, double)>(&SimTK::Geo::BicubicBezierPatch::evalPUsingB));
  types.method("evalP1UsingB", static_cast<void (*)(const SimTK::Mat<4,4, SimTK::Vec3> &, double, double, SimTK::Vec3 &, SimTK::Vec3 &)>(&SimTK::Geo::BicubicBezierPatch::evalP1UsingB));
  types.method("evalP2UsingB", static_cast<void (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicBezierPatch::evalP2UsingB));
  types.method("evalP3UsingB", static_cast<void (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double, double, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&, SimTK::Vec3&)>(&SimTK::Geo::BicubicBezierPatch::evalP3UsingB));
  types.method("calcIsoCurveU", static_cast<SimTK::Geo::CubicBezierCurve (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double)>(&SimTK::Geo::BicubicBezierPatch::calcIsoCurveU));
  types.method("calcIsoCurveW", static_cast<SimTK::Geo::CubicBezierCurve (*)(const SimTK::Mat<4,4,SimTK::Vec3>&, double)>(&SimTK::Geo::BicubicBezierPatch::calcIsoCurveW));
  types.method("calcAFromB", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcAFromB));
  types.method("calcBFromA", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcBFromA));
  types.method("calcHFromB", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcHFromB));
  types.method("calcBFromH", static_cast<SimTK::Mat<4,4,SimTK::Vec3> (*)(const SimTK::Mat<4,4,SimTK::Vec3>&)>(&SimTK::Geo::BicubicBezierPatch::calcBFromH));

  /* End of SimTK::Geo::BicubicBezierPatch_ class method wrappers
   **********************************************************************/

  /**********************************************************************/
  /* Wrappers for the methods of class SimTK::Geodesic
   */

  DEBUG_MSG("Adding wrapper for int SimTK::Geodesic::getNumPoints() (" __HERE__ ")");
  // signature to use in the veto list: int SimTK::Geodesic::getNumPoints()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:56:9
  t15.method("getNumPoints", static_cast<int (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getNumPoints));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Transform> & SimTK::Geodesic::getFrenetFrames() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Transform> & SimTK::Geodesic::getFrenetFrames()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:66:30
  t15.method("getFrenetFrames", static_cast<const SimTK::Array_<SimTK::Transform> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getFrenetFrames));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Transform> & SimTK::Geodesic::updFrenetFrames() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Transform> & SimTK::Geodesic::updFrenetFrames()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:67:30
  t15.method("updFrenetFrames", static_cast<SimTK::Array_<SimTK::Transform> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updFrenetFrames));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addFrenetFrame(const SimTK::Transform &) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addFrenetFrame(const SimTK::Transform &)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:68:10
  t15.method("addFrenetFrame", static_cast<void (SimTK::Geodesic::*)(const SimTK::Transform &) >(&SimTK::Geodesic::addFrenetFrame));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Real> & SimTK::Geodesic::updArcLengths() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Real> & SimTK::Geodesic::updArcLengths()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:70:19
  t15.method("updArcLengths", static_cast<SimTK::Array_<SimTK::Real> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updArcLengths));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Real> & SimTK::Geodesic::getArcLengths() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Real> & SimTK::Geodesic::getArcLengths()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:71:25
  t15.method("getArcLengths", static_cast<const SimTK::Array_<SimTK::Real> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getArcLengths));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addArcLength(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addArcLength(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:72:10
  t15.method("addArcLength", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::addArcLength));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Real> & SimTK::Geodesic::updCurvatures() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Real> & SimTK::Geodesic::updCurvatures()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:74:19
  t15.method("updCurvatures", static_cast<SimTK::Array_<SimTK::Real> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updCurvatures));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Real> & SimTK::Geodesic::getCurvatures() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Real> & SimTK::Geodesic::getCurvatures()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:75:25
  t15.method("getCurvatures", static_cast<const SimTK::Array_<SimTK::Real> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getCurvatures));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addCurvature(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addCurvature(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:76:10
  t15.method("addCurvature", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::addCurvature));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updDirectionalSensitivityPtoQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updDirectionalSensitivityPtoQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:78:19
  t15.method("updDirectionalSensitivityPtoQ", static_cast<SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updDirectionalSensitivityPtoQ));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getDirectionalSensitivityPtoQ() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getDirectionalSensitivityPtoQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:80:25
  t15.method("getDirectionalSensitivityPtoQ", static_cast<const SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getDirectionalSensitivityPtoQ));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addDirectionalSensitivityPtoQ(const SimTK::Vec2 &) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addDirectionalSensitivityPtoQ(const SimTK::Vec2 &)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:82:10
  t15.method("addDirectionalSensitivityPtoQ", static_cast<void (SimTK::Geodesic::*)(const SimTK::Vec2 &) >(&SimTK::Geodesic::addDirectionalSensitivityPtoQ));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updDirectionalSensitivityQtoP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updDirectionalSensitivityQtoP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:86:19
  t15.method("updDirectionalSensitivityQtoP", static_cast<SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updDirectionalSensitivityQtoP));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getDirectionalSensitivityQtoP() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getDirectionalSensitivityQtoP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:88:25
  t15.method("getDirectionalSensitivityQtoP", static_cast<const SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getDirectionalSensitivityQtoP));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addDirectionalSensitivityQtoP(const SimTK::Vec2 &) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addDirectionalSensitivityQtoP(const SimTK::Vec2 &)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:90:10
  t15.method("addDirectionalSensitivityQtoP", static_cast<void (SimTK::Geodesic::*)(const SimTK::Vec2 &) >(&SimTK::Geodesic::addDirectionalSensitivityQtoP));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updPositionalSensitivityPtoQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updPositionalSensitivityPtoQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:94:19
  t15.method("updPositionalSensitivityPtoQ", static_cast<SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updPositionalSensitivityPtoQ));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getPositionalSensitivityPtoQ() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getPositionalSensitivityPtoQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:96:25
  t15.method("getPositionalSensitivityPtoQ", static_cast<const SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getPositionalSensitivityPtoQ));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addPositionalSensitivityPtoQ(const SimTK::Vec2 &) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addPositionalSensitivityPtoQ(const SimTK::Vec2 &)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:98:10
  t15.method("addPositionalSensitivityPtoQ", static_cast<void (SimTK::Geodesic::*)(const SimTK::Vec2 &) >(&SimTK::Geodesic::addPositionalSensitivityPtoQ));

  DEBUG_MSG("Adding wrapper for SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updPositionalSensitivityQtoP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::updPositionalSensitivityQtoP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:102:19
  t15.method("updPositionalSensitivityQtoP", static_cast<SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)() >(&SimTK::Geodesic::updPositionalSensitivityQtoP));

  DEBUG_MSG("Adding wrapper for const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getPositionalSensitivityQtoP() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Array_<SimTK::Vec2> & SimTK::Geodesic::getPositionalSensitivityQtoP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:104:25
  t15.method("getPositionalSensitivityQtoP", static_cast<const SimTK::Array_<SimTK::Vec2> & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getPositionalSensitivityQtoP));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::addPositionalSensitivityQtoP(const SimTK::Vec2 &) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::addPositionalSensitivityQtoP(const SimTK::Vec2 &)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:106:10
  t15.method("addPositionalSensitivityQtoP", static_cast<void (SimTK::Geodesic::*)(const SimTK::Vec2 &) >(&SimTK::Geodesic::addPositionalSensitivityQtoP));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setTorsionAtP(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setTorsionAtP(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:110:10
  t15.method("setTorsionAtP", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::setTorsionAtP));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setTorsionAtQ(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setTorsionAtQ(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:111:10
  t15.method("setTorsionAtQ", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::setTorsionAtQ));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setBinormalCurvatureAtP(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setBinormalCurvatureAtP(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:112:10
  t15.method("setBinormalCurvatureAtP", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::setBinormalCurvatureAtP));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setBinormalCurvatureAtQ(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setBinormalCurvatureAtQ(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:113:10
  t15.method("setBinormalCurvatureAtQ", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::setBinormalCurvatureAtQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getLength() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getLength()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:117:10
  t15.method("getLength", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getLength));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::calcLengthDot(const SimTK::Vec3 &, const SimTK::Vec3 &) (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::calcLengthDot(const SimTK::Vec3 &, const SimTK::Vec3 &)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:124:10
  t15.method("calcLengthDot", static_cast<SimTK::Real (SimTK::Geodesic::*)(const SimTK::Vec3 &, const SimTK::Vec3 &)  const>(&SimTK::Geodesic::calcLengthDot));

  DEBUG_MSG("Adding wrapper for const SimTK::Vec3 & SimTK::Geodesic::getPointP() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Vec3 & SimTK::Geodesic::getPointP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:129:17
  t15.method("getPointP", static_cast<const SimTK::Vec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getPointP));

  DEBUG_MSG("Adding wrapper for const SimTK::Vec3 & SimTK::Geodesic::getPointQ() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::Vec3 & SimTK::Geodesic::getPointQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:132:17
  t15.method("getPointQ", static_cast<const SimTK::Vec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getPointQ));

  DEBUG_MSG("Adding wrapper for const SimTK::UnitVec3 & SimTK::Geodesic::getNormalP() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::UnitVec3 & SimTK::Geodesic::getNormalP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:137:21
  t15.method("getNormalP", static_cast<const SimTK::UnitVec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getNormalP));

  DEBUG_MSG("Adding wrapper for const SimTK::UnitVec3 & SimTK::Geodesic::getNormalQ() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::UnitVec3 & SimTK::Geodesic::getNormalQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:141:21
  t15.method("getNormalQ", static_cast<const SimTK::UnitVec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getNormalQ));

  DEBUG_MSG("Adding wrapper for const SimTK::UnitVec3 & SimTK::Geodesic::getTangentP() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::UnitVec3 & SimTK::Geodesic::getTangentP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:145:21
  t15.method("getTangentP", static_cast<const SimTK::UnitVec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getTangentP));

  DEBUG_MSG("Adding wrapper for const SimTK::UnitVec3 & SimTK::Geodesic::getTangentQ() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::UnitVec3 & SimTK::Geodesic::getTangentQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:148:21
  t15.method("getTangentQ", static_cast<const SimTK::UnitVec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getTangentQ));

  DEBUG_MSG("Adding wrapper for const SimTK::UnitVec3 & SimTK::Geodesic::getBinormalP() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::UnitVec3 & SimTK::Geodesic::getBinormalP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:152:21
  t15.method("getBinormalP", static_cast<const SimTK::UnitVec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getBinormalP));

  DEBUG_MSG("Adding wrapper for const SimTK::UnitVec3 & SimTK::Geodesic::getBinormalQ() (" __HERE__ ")");
  // signature to use in the veto list: const SimTK::UnitVec3 & SimTK::Geodesic::getBinormalQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:155:21
  t15.method("getBinormalQ", static_cast<const SimTK::UnitVec3 & (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getBinormalQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getCurvatureP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getCurvatureP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:162:10
  t15.method("getCurvatureP", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getCurvatureP));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getCurvatureQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getCurvatureQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:170:10
  t15.method("getCurvatureQ", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getCurvatureQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getTorsionP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getTorsionP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:176:10
  t15.method("getTorsionP", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getTorsionP));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getTorsionQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getTorsionQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:181:10
  t15.method("getTorsionQ", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getTorsionQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getBinormalCurvatureP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getBinormalCurvatureP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:186:10
  t15.method("getBinormalCurvatureP", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getBinormalCurvatureP));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getBinormalCurvatureQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getBinormalCurvatureQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:190:10
  t15.method("getBinormalCurvatureQ", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getBinormalCurvatureQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:197:10
  t15.method("getJacobiP", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiP));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:203:10
  t15.method("getJacobiQ", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiPDot() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiPDot()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:210:10
  t15.method("getJacobiPDot", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiPDot));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiQDot() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiQDot()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:213:10
  t15.method("getJacobiQDot", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiQDot));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiTransP() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiTransP()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:216:10
  t15.method("getJacobiTransP", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiTransP));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiTransQ() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiTransQ()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:217:10
  t15.method("getJacobiTransQ", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiTransQ));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiTransPDot() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiTransPDot()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:218:10
  t15.method("getJacobiTransPDot", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiTransPDot));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getJacobiTransQDot() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getJacobiTransQDot()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:219:10
  t15.method("getJacobiTransQDot", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getJacobiTransQDot));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::clear() (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::clear()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:223:10
  t15.method("clear", static_cast<void (SimTK::Geodesic::*)() >(&SimTK::Geodesic::clear));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setIsConvex(bool) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setIsConvex(bool)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:237:10
  t15.method("setIsConvex", static_cast<void (SimTK::Geodesic::*)(bool) >(&SimTK::Geodesic::setIsConvex));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setIsShortest(bool) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setIsShortest(bool)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:238:10
  t15.method("setIsShortest", static_cast<void (SimTK::Geodesic::*)(bool) >(&SimTK::Geodesic::setIsShortest));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setInitialStepSizeHint(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setInitialStepSizeHint(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:239:10
  t15.method("setInitialStepSizeHint", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::setInitialStepSizeHint));

  DEBUG_MSG("Adding wrapper for void SimTK::Geodesic::setAchievedAccuracy(SimTK::Real) (" __HERE__ ")");
  // signature to use in the veto list: void SimTK::Geodesic::setAchievedAccuracy(SimTK::Real)
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:240:10
  t15.method("setAchievedAccuracy", static_cast<void (SimTK::Geodesic::*)(SimTK::Real) >(&SimTK::Geodesic::setAchievedAccuracy));

  DEBUG_MSG("Adding wrapper for bool SimTK::Geodesic::isConvex() (" __HERE__ ")");
  // signature to use in the veto list: bool SimTK::Geodesic::isConvex()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:242:10
  t15.method("isConvex", static_cast<bool (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::isConvex));

  DEBUG_MSG("Adding wrapper for bool SimTK::Geodesic::isShortest() (" __HERE__ ")");
  // signature to use in the veto list: bool SimTK::Geodesic::isShortest()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:243:10
  t15.method("isShortest", static_cast<bool (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::isShortest));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getInitialStepSizeHint() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getInitialStepSizeHint()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:244:10
  t15.method("getInitialStepSizeHint", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getInitialStepSizeHint));

  DEBUG_MSG("Adding wrapper for SimTK::Real SimTK::Geodesic::getAchievedAccuracy() (" __HERE__ ")");
  // signature to use in the veto list: SimTK::Real SimTK::Geodesic::getAchievedAccuracy()
  // defined in /opt/opensim-core-fullrelease/sdk/include/simbody/simmath/internal/Geodesic.h:245:10
  t15.method("getAchievedAccuracy", static_cast<SimTK::Real (SimTK::Geodesic::*)()  const>(&SimTK::Geodesic::getAchievedAccuracy));

  /* End of SimTK::Geodesic class method wrappers
   **********************************************************************/

  types.method("isCusp", static_cast<bool (*)(const SimTK::Vec<3,double> &)>(&SimTK::Geo::isCusp));

  // static bool 	isInflectionPoint (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("isInflectionPoint", static_cast<bool (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::isInflectionPoint));

  // static UnitVec< RealP, 1 > 	calcUnitTangent (const Vec< 3, RealP, S > &Pu)
  types.method("calcUnitTangent", static_cast<SimTK::UnitVec<double,1> (*)(const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcUnitTangent));

  // static Vec< 3, RealP > 	calcCurvatureVector (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("calcCurvatureVector", static_cast<SimTK::Vec<3,double> (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcCurvatureVector));

  // static UnitVec< RealP, 1 > 	calcUnitNormal (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("calcUnitNormal", static_cast<SimTK::UnitVec<double,1> (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcUnitNormal));

  // static RealP 	calcCurveFrame (const Vec< 3, RealP, S > &P, const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu, Transform_< RealP > &X_FP)
  types.method("calcCurveFrame", static_cast<double (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &, SimTK::Transform_<double> &)>(&SimTK::Geo::calcCurveFrame));

  // static RealP 	calcCurvatureSqr (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu)
  types.method("calcCurvatureSqr", static_cast<double (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcCurvatureSqr));

  // static RealP 	calcTorsion (const Vec< 3, RealP, S > &Pu, const Vec< 3, RealP, S > &Puu, const Vec< 3, RealP, S > &Puuu)
  types.method("calcTorsion", static_cast<double (*)(const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &, const SimTK::Vec<3,double> &)>(&SimTK::Geo::calcTorsion));

  // static void 	findClosestPointsOfTwoLines (const Vec< 3, RealP > &p0, const UnitVec< RealP, 1 > &d0, const Vec< 3, RealP > &p1, const UnitVec< RealP, 1 > &d1, Vec< 3, RealP > &x0, Vec< 3, RealP > &x1, bool &linesAreParallel)
  types.method("findClosestPointsOfTwoLines", static_cast<void (*)(const SimTK::Vec<3,double> &, const SimTK::UnitVec<double,1> &, const SimTK::Vec<3,double> &, const SimTK::UnitVec<double,1> &, SimTK::Vec<3,double> &, SimTK::Vec<3,double> &, bool &)>(&SimTK::Geo::findClosestPointsOfTwoLines));

  DEBUG_MSG("End of wrapper definitions");

}
}
